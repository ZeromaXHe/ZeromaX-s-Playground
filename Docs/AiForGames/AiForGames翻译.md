# 第 I 部分 AI 和游戏

# 第 1 章：介绍

## 1.2 游戏 AI 模型

在这本书中，有大量的算法和技术。它很容易丢失，所以了解这些比特是如何组合在一起的很重要。

为了提供帮助，我使用了一种一致的结构来将游戏中使用的AI情境化。这不是唯一可能的模型，也不是唯一能从本书中的技术中受益的模型。但为了使讨论更清晰，我将展示每种技术如何融入制作智能游戏角色的一般结构中。

图1.1说明了这个模型。它将人工智能任务分为三个部分：运动、决策和战略。前两部分包含逐个角色工作的算法，最后一部分在团队或一方工作。围绕这三个AI元素是一整套额外的基础设施。

并非所有游戏应用程序都需要所有级别的人工智能。国际象棋或风险等棋盘游戏只需要策略级别；游戏中的角色（如果可以这样称呼的话）不会自己做决定，也不需要担心如何移动。

另一方面，在许多游戏中根本没有策略。平台游戏中的非玩家角色，如《空洞骑士》[183]或《超级马里奥兄弟》[152]，纯粹是被动的，他们自己做出简单的决定并付诸行动。没有协调来确保敌方角色在挫败玩家方面做得最好。

### 1.2.1 移动

运动是指将决策转化为某种运动的算法。当一个没有投射物攻击的敌方角色需要攻击《超级马里奥阳光》中的玩家时[154]，它首先会直接向玩家前进。当它足够接近时，它实际上可以进行攻击。攻击的决定是由一组以玩家位置为中心的运动算法来执行的。只有这样，才能播放攻击动画并耗尽玩家的生命值。

移动算法可能比简单的归位更复杂。角色可能需要避开路上的障碍物，甚至需要穿过一系列房间。分裂细胞[189]中某些级别的守卫会通过发出警报来回应玩家的出现。这可能需要导航到最近的壁挂式报警点，该报警点可能很远，可能涉及绕过障碍物或穿过走廊的复杂导航。

许多动作都是直接使用动画执行的。如果《模拟人生》中的模拟人生坐在桌子旁，面前摆着食物，想进行进食动作，那么进食动画就会简单地播放。一旦人工智能决定角色应该吃东西，就不需要再使用人工智能了（本书不涉及所使用的动画技术）。然而，如果同一个角色在她想吃东西的时候在后门，运动AI需要引导她到椅子上（或附近的其他食物来源）。

### 1.2.2 决策

决策涉及角色制定下一步该做什么。通常，每个角色都有一系列不同的行为可供选择：攻击、静止、隐藏、探索、巡逻等。决策系统需要在游戏的每个时刻找出这些行为中哪种最合适。然后，可以使用运动AI和动画技术来执行所选的行为。

简单地说，一个角色可能有非常简单的规则来选择行为。塞尔达游戏中各个级别的农场动物将静止不动，除非玩家靠得太近，然后它们会移动一小段距离。

在另一个极端，《半条命 2》[194]中的敌人表现出复杂的决策，他们会尝试多种不同的策略来接近玩家：将投掷手榴弹和放下压制火力等中间动作联系在一起，以实现他们的目标。

有些决定可能需要移动AI来执行。近战（肉搏）攻击需要角色靠近受害者。在战斗密集型游戏中，如《黑暗之魂》[115]，决策会将角色移向目标，并决定执行哪种攻击，从而决定执行哪一种动画。在其他游戏中，一旦做出决定，就会在没有任何额外动作的情况下播放预定的动画（例如，吃模拟人），或者在没有任何视觉反馈的情况下直接修改游戏状态（例如，当 Sid Meier's Civilization VI[113]中的国家 AI 选择研究一项新技术时，它只是在没有给玩家视觉反馈的条件下发生）。

### 1.2.3 战略

你可以用动作AI和决策AI走很长的路，大多数基于动作的三维（3D）游戏只使用这两个元素。但要协调整个团队，需要一些战略性的人工智能。

在本书中，策略是指一组角色所使用的总体方法。在这一类中，人工智能算法不仅控制一个角色，还会影响一组角色的行为。组中的每个角色可能（通常也会）有自己的决策和移动算法，但总体而言，他们的决策将受到组策略的影响。

在最初的《半条命》[193]中，敌人作为一个团队包围并消灭了玩家。一个人经常冲过球员，占据侧翼位置。最近的游戏也遵循了这一点，例如《荣誉勋章》系列中不断发展的人工智能引擎[78]。随着时间的推移，我们看到敌人团队可以采取的战略行动越来越复杂。

### 1.2.4 基础设施

然而，人工智能算法本身只是故事的一半。为了真正为游戏构建人工智能，我们需要一整套额外的基础设施。运动请求需要通过使用动画或越来越多的物理模拟在游戏中转化为动作。

同样，AI需要游戏中的信息来做出明智的决定。这有时被称为“感知”（尤其是在学术人工智能中）：找出角色所知道的信息。在实践中，它比模拟每个角色能看到或听到的要广泛得多，但包括游戏世界和人工智能之间的所有接口。这种世界接口通常是人工智能程序员所做工作的重要组成部分，根据我的经验，它在人工智能调试工作中占很大比例。

最后，需要对整个 AI 系统进行管理，以便使用适量的处理器时间和内存。虽然游戏的每个领域通常都有某种执行管理（例如渲染的细节级别算法），但管理人工智能会产生一整套自己的技术和算法。

这些组件中的每一个都可能被认为不属于人工智能开发人员的职权范围。有时它们是（特别是，动画系统通常是图形引擎的一部分，或者越来越多地有自己的专用程序员），但它们对于让人工智能工作至关重要，无法完全避免。在这本书中，我对除动画之外的每个基础设施组件都进行了深入的介绍。

### 1.2.5 基于代理的人工智能

我在这本书中很少使用“代理”一词，尽管我描述的模型是基于代理的模型。

在这种情况下，基于代理的人工智能是关于产生自主角色，这些角色从游戏数据中获取信息，根据信息确定要采取的行动，并执行这些行动。

它可以被视为自下而上的设计：你首先要弄清楚每个角色的行为方式，并实现支持这一点所需的人工智能。游戏的整体行为取决于各个角色的行为如何协同工作。我们将使用的 AI 模型的前两个元素，移动和决策，构成了游戏中代理的 AI。

相比之下，非基于代理的人工智能试图找出一切应该如何自上而下地运作，并构建一个单一的系统来模拟一切。一个例子是《侠盗猎车手 3》城市的交通和行人模拟[104]。整体交通和行人流量是根据一天中的时间和城市区域计算的，只有当玩家看到时，才会变成单独的汽车和人。

然而，这种区别是模糊的。我们将研究自上而下的细节技术，而大多数角色 AI 都是自下而上的。一个好的人工智能开发人员会混合使用任何可靠的技术来完成工作，无论采用何种方法。这种务实的方法是我一直遵循的。因此，在这本书中，我避免使用基于代理的术语，更喜欢笼统地谈论游戏角色，无论它们的结构如何。

### 1.2.6 书中

在本书的文本中，每一章都将引用这种人工智能模型，指出该主题适合的地方。该模型有助于理解事物是如何连接的，以及哪些技术是其他技术的替代品。

但分界线并不总是很明显；这是一个通用的模型，而不是紧身衣。在最终的游戏代码中没有连接。每个类别的整套人工智能技术以及许多基础设施都将无缝地协同工作。

许多技术在多个类别中发挥作用。例如，寻路既是一种运动，也是一种决策技巧。同样，一些分析游戏环境中威胁和机遇的战术算法可以用作单个角色的决策者，也可以用于确定整个团队的策略。

# 第 2 章：游戏 AI

## 2.3 速度和内存限制

AI 开发人员工作的最大限制是机器的物理限制。游戏 AI 没有数天的处理时间和数 TB 的内存。我们甚至没有足够的空间使用游戏所运行的计算机的所有处理器和内存。其他任务需要空间和时间，如图形、声音、网络和输入。在团队中，不同组的开发人员必须并行处理他们的专业，将设定速度和内存预算。

学术界或商业研究的人工智能技术没有得到广泛使用的原因之一是它们的处理时间或内存要求。一个在简单演示中可能很有吸引力的算法可能会使生产游戏陷入停滞。

本节着眼于与 AI 代码的设计和构造相关的低级硬件问题。这里包含的大部分内容都是对所有游戏代码的一般建议。如果你了解当前的游戏编程问题，只想了解人工智能，你可以安全地跳过这一节。

### 2.3.1 处理器问题

游戏效率最明显的限制是运行游戏的处理器的速度。最初，所有的游戏机都有一个主处理器，它也负责图形处理。大多数游戏硬件现在都有几个 CPU（通常在同一块硅片上有几个处理核心），以及用于处理图形的专用 GPU。

一般来说，CPU 更快、更灵活，GPU 更并行。当任务可以拆分为许多同时运行的简单子任务时，GPU 上的数万到数千个处理核心可以比 CPU 上顺序运行的相同任务快几个数量级。

图形卡驱动程序过去有“固定功能”管道，图形代码内置于驱动程序中，只能在狭窄的参数范围内进行调整。除了图形卡上的图形之外，不可能做太多其他事情。现在，驱动程序支持 Vulkan、DirectX 11、CUDA 和 OpenCL 等技术，这些技术允许在 GPU 上执行通用代码。因此，更多的功能被转移到 GPU 上，释放了 CPU 上更多的处理能力。

在过去的二十年里，人工智能处理时间的份额断断续续地增长。在某些情况下，现在占了 CPU 负载的大部分，一些 AI 在 GPU 上运行。随着处理器速度的提高，对于想要应用更复杂算法的人工智能开发人员来说，这显然是个好消息，特别是在决策和战略制定方面。但是，虽然处理器时间的增量改进有助于解锁新技术，但它们并没有解决根本问题。许多 AI 算法需要很长时间才能运行。一个全面的寻路系统每个字符可能需要几十毫秒才能运行。显然，在包含 1000 个字符的 RTS 中，没有机会运行每一帧。

在游戏中工作的复杂人工智能需要被拆分为可以分布在多个帧上的小块组件。关于资源管理的章节展示了如何实现这一目标。将这些技术应用于许多长期运行的AI算法可以使它们进入实用领域。

#### 低级别问题

在过去的10年里，该行业的一个重大变化是，C++ 不再在游戏编程领域占据主导地位。现在，角色行为、游戏逻辑和人工智能通常是用 C#、Swift、Java 甚至脚本语言等高级语言编写的。这很重要，因为这些语言为程序员提供了较少的微观管理代码性能特征的能力。还有一些人工智能程序员仍在使用 C++，他们仍然需要对处理器的“裸机”性能特征有很好的了解，但根据我最近的经验，这些程序员往往是从事人工智能引擎工作的低级专家：旨在在多个游戏中重用的功能组合。

在本书的第一版和第二版中，我详细描述了三个低级问题：SIMD、超标量体系结构和虚拟函数。在本期中，我将简要介绍它们。出于我将在下面描述的原因，在我自己的专业实践中，我已经好几年没有直接关注这些问题了。

SIMD（单指令多数据）是现代硬件上的一组寄存器，其大小足以容纳多个浮点数。数学运算符可以应用于这些寄存器，其效果是对多条数据并行运行相同的代码。这可以大大加快一些代码的速度，特别是几何推理。尽管 CPU 有专门的 SIMD 寄存器，但它们提供了最适合 GPU 的代码加速。当代码可以移动到 GPU 上时，在 CPU 上优化 SIMD 通常是多余的。

超标量 CPU 同时具有多个活动的执行路径。代码被拆分为多个部分并行执行，然后将结果重新组合成最终结果。当一个管道的结果依赖于另一个管道时，这可能涉及等待，或者猜测结果可能是什么，如果结果被证明是错误的，则重新进行工作（称为分支预测）。在过去的十年里，多核 CPU 几乎无处不在，其中几个独立的 CPU 允许不同的线程并行运行。尽管每个核心可能仍然是超标量的，但现在这在很大程度上被视为幕后细节，与人工智能程序员无关。通过专注于使 AI 代码可并行化，而不是担心分支预测的细节，可以获得更好的速度。

AI 代码可以利用这种并行性，要么在不同线程中为不同角色运行 AI，要么在其他游戏系统的不同线程中运行所有 AI。如果可用，这些线程将在不同的内核上并行执行。多个线程做同一件事（比如一个字符在每个线程中运行其 AI）通常更具性能，因为更容易确保所有处理器都使用相同的容量，并且更灵活，因为它可以在不重新平衡到具有不同数量内核的硬件的情况下进行扩展。

当人工智能通常必须小心使用的每一个 CPU 周期时，通常会避免使用 C++ 中的虚拟类，因为它们的虚拟函数调用开销很大。这意味着尽可能避免面向对象的多态性。虚拟函数调用将函数实现的内存位置存储在变量中（在称为函数表或 vtable 的结构中）。因此，调用函数需要在运行时查找变量，然后查找变量指定的位置。虽然这种额外的查找使用了很少的时间，但它可以与分支预测器和处理器缓存进行显著交互。因此，虚拟函数，以及多态性，名声不佳。在过去的 10 年里，这一声誉在很大程度上已经消失了。这本书中的代码总是以多态风格编写的。现在，Unity、Unreal、Lumberyard 和 Godot 等游戏引擎假设游戏逻辑将是多态的。

### 2.3.2 内存问题

大多数AI算法不需要大量的 RAM，通常只有几块，最多可达数十兆字节。这种小的存储需求在普通的移动设备上很容易实现，对于地形分析和寻路等重量级算法来说是足够的。大型多人在线游戏（MMOG）通常需要更多的存储空间来容纳更大的世界，但它们是在可以安装足够内存的服务器场上运行的（即使这样，我们也只谈论千兆字节的 RAM，很少更多）。巨大的世界通常被分割成单独的部分，或者字符被限制在某些区域，进一步降低了人工智能的内存需求。

因此，限制因素通常不是内存量，而是使用方式。分配和缓存一致性都是影响性能的内存问题。它们都可以影响AI算法的实现。

#### 分配和垃圾收集

分配是请求将数据放置在内存中的过程。当不再需要该内存时，称为释放或释放。只要内存可用，分配和释放就相对较快。

C 等低级语言要求程序员手动释放内存。当为特定对象分配内存时，C++ 和 Swift 等语言会提供“引用计数”功能这存储了知道对象存在的位置的数量。当对象不再被引用时，计数器将降至 0，内存将被释放。不幸的是，这两种方法都可能意味着应该释放的内存永远不会被释放。要么程序员忘记手动释放，要么存在一组循环引用，使得它们的计数器永远不会降至 0。许多高级语言实现了复杂的算法来收集这种“垃圾”，即不再有用的空闲内存。不幸的是，垃圾收集可能很昂贵。在 C# 等语言中，特别是在运行 Unity 游戏引擎的 mono 运行时，垃圾收集可能会慢到足以延迟渲染帧，从而导致视觉上的卡顿。这对大多数开发人员来说是不可接受的。

因此，为高级语言实现 AI 算法通常涉及在级别运行时尽量不分配和取消分配对象。整个级别所需的数据在级别开始时保留，只有在级别结束时才释放。本书中的几个算法假设可以随时创建新对象，并在不再需要时将其消失。在垃圾收集耗时的平台上，修改这些实现可能很重要。例如：当首次考虑地图中的每个位置时，第 4 章中的几种寻路算法会为该位置创建和存储数据。当路径完成时，不需要任何中间位置数据。垃圾回收友好的实现可能会创建一个单一的寻路对象，其中包含地图中每个位置的数据。每当需要寻路时，都会调用同一个对象，它使用所需的预分配位置数据，忽略其余数据。就其本身而言，这种实现会稍微复杂一些，如果需要寻路的多个字符必须排队才能使用一个寻路对象，则可能会更加复杂。为了避免使底层算法复杂化，本书以最简单的形式呈现了它们：不考虑分配。

#### 高速缓冲存储器（Cache）

内存大小本身并不是内存使用的唯一限制。从 RAM 访问内存并将其准备供处理器使用所需的时间明显长于处理器执行操作的时间。如果处理器必须依赖主 RAM，它们将不断地等待数据。

所有现代处理器都至少使用一级缓存：处理器中保存的 RAM 副本，可以非常快速地操作。缓存通常以页的形式获取；主存储器的整个部分被流式传输到处理器。然后可以随意操纵。当处理器完成工作后，缓存的内存会被发送回主内存。处理器通常无法在主内存上工作：它需要的所有内存都必须在缓存上。操作系统可能会为此增加额外的复杂性，因为内存请求可能必须通过操作系统例程，该例程将请求转换为对真实或虚拟内存的请求。这可能会引入进一步的限制，因为具有相似映射地址的两位物理内存可能无法同时使用（称为混叠故障）。

多级缓存的工作方式与单个缓存相同。大量内存被提取到最低级别的缓存，其中一个子集被提取到每个更高级别的缓存中，处理器只在最高级别上工作。

如果一个算法使用内存中分散的数据，那么缓存中不太可能随时都有正确的内存。这些缓存未命中在时间上代价高昂。处理器必须将一个或两个指令的全新内存块提取到缓存中，然后必须将其全部流式输出并请求另一个块。一个好的分析系统会显示何时发生缓存未命中。根据我的经验，即使在不让你控制内存布局的语言中，通过确保一个算法所需的所有数据都保存在同一个地方，在相同的几个对象中，也可以实现显著的速度提升。

在这本书中，为了便于理解，我使用了面向对象的风格来布局数据。特定游戏对象的所有数据都保存在一起。这可能不是缓存效率最高的解决方案。在一个有 1000 个角色的游戏中，最好将他们的所有位置放在一个数组中，这样基于位置进行计算的算法就不需要不断地在内存中跳跃。与所有优化一样，分析就是一切，但通过考虑数据一致性进行编程，可以获得一般水平的效率。

### 2.3.3 平台

随着行业围绕少数游戏引擎的集中化，平台差异对人工智能设计的影响比以前小了。例如，图形程序员可能仍然需要担心控制台与移动设备。但人工智能编程往往更通用。在本节中，我将考虑每个主要的游戏平台，重点介绍 AI 代码特有的任何问题。

#### 个人电脑（PC）

PC 可能是最强大的游戏机，铁杆游戏玩家会购买高端昂贵的硬件。但由于缺乏一致性，它们可能会让开发人员感到沮丧。当控制台具有固定硬件（或至少相对较少的变化）时，PC 的不同配置令人眼花缭乱。具有一对顶级视频卡、SSD 驱动器和快速内存的机器与具有集成图形的廉价 PC 之间存在巨大差异。

事情比以前容易了：低级开发人员依靠 Vulkan 和 DirectX 等应用程序编程接口（API）将其与大多数硬件细节隔离开来，但游戏仍需要检测功能支持和速度，并相应地进行调整。在 Unity 和 Unreal 等引擎中工作的开发人员更容易上手，但可能仍需要使用内置的功能检测来确保他们的游戏在所有系统上运行良好。

使用 PC 需要构建软件，可以从休闲玩家的有限系统扩展到铁杆粉丝的最新硬件。对于图形，这种缩放可以合理地模块化；例如，对于低规格的机器，我们关闭了高级渲染功能。可以使用更简单的阴影算法，或者用简单的纹理映射替换基于物理的着色器。图形复杂度的变化通常不会改变游戏玩法。

AI 是不同的。如果人工智能的工作时间减少，它应该如何应对？它可以尝试执行更少的工作。这实际上相当于拥有更多愚蠢的人工智能，并可能影响游戏的难度。在规格较低的机器上让你的游戏更容易可能是不可接受的。同样，如果我们试图执行相同数量的工作，可能需要更长的时间。这可能意味着较低的帧率，也可能意味着做出决策的角色之间有更多的帧。反应迟钝的角色通常也更容易与之对抗，并可能导致 QA 出现同样的问题。

大多数开发人员使用的解决方案是将 AI 瞄准最低的共同点：技术设计文档中列出的最低规格机器。人工智能的时间根本不会随着机器的能力而扩展。更快的机器只是在人工智能上按比例减少了处理预算。

然而，在许多游戏中，可扩展的人工智能是可行的。许多游戏使用人工智能来控制环境中的角色：人行道上的行人、为比赛欢呼的人群或天空中成群结队的鸟。这种人工智能是可自由扩展的：当处理器时间可用时，可以使用更多的字符。第 10 章介绍了一些可以应对这种可扩展性的细节级别AI技术。

#### 主机平台（Console）

主机比 PC 更容易使用。您确切地知道您的目标机器，并且通常可以在目标机器上看到正在运行的代码。新硬件或不断变化的API版本无需担心未来。

使用下一代技术的开发人员通常没有最终机器的确切规格或可靠的硬件平台（初始开发套件通常只不过是一个专用的模拟器），但大多数控制台开发都有一个相当固定的目标。

技术要求清单（TRC）流程是游戏机制造商对游戏操作设定最低标准的过程，用于确定帧率等问题（尽管不同地区可能有所不同，例如 PAL 和 NTSC）。这意味着 AI 预算可以在固定的毫秒数内锁定。反过来，这使得更容易确定可以使用哪些算法，并有一个固定的优化目标（前提是预算在最后一个里程碑没有被削减，为竞争对手游戏中使用的最新图形技术让路）。

用于 PC 开发的相同游戏引擎针对的是游戏机，这使得跨平台开发比过去容易得多。幸运的是，很少有创建游戏的 AI 开发人员现在正在处理特定游戏机的低级细节。几乎所有的底层代码都由引擎或中间件处理。

#### 移动平台（Mobile）

苹果公司于 2007 年推出了 iPhone，开创了自80年代家用游戏机以来最大的游戏革命。当这本书的第一版于 2006 年发行时，移动游戏由 PlayStation Portable（PSP）和任天堂的 GameBoy advance 等专用手持游戏机组成。现在几乎 100% 的市场都是手机和平板电脑。

该领域有两个平台：苹果及其 iOS 设备（iPhone、iPad、iPod Touch）和安卓。直到最近，这些游戏都非常不同，需要为每个游戏单独编码。虽然两者都可以使用C和C++等低级语言，但对于高级语言，苹果鼓励使用 Swift（以前使用 Objective-C）和 Android Java（或编译成 Java 字节码的语言，如 Kotlin）。

按市场份额计算的主要游戏引擎（虚幻和 Unity）以及许多较小的竞争对手（如 Godot）都支持具有相同游戏代码的移动平台，因此不需要特定于平台的实现。移动开发人员使用这些工具，以跨平台的方式工作，这已经发生了很大的转变。考虑到 Steam 平台是在 PC 上运行的移动游戏的可行市场，我认为毫无疑问，这一趋势很快就会变得几乎无处不在。

能够运行游戏的智能手机是功能强大的机器，与上一代游戏机和 5-10 年前的 PC 相当。可以在 PC 或主机上运行的人工智能与可以在移动设备上运行的 AI 之间不再有任何实际区别。手机可能需要更简单的图形或更小的人群规模，但就算法而言，现在同样适用。

#### 虚拟和增强现实

在撰写本文时，即 2019 年初，虚拟现实和增强现实都被大肆宣传，在游戏市场中只占很小一部分。技术和市场正在快速变化，除了一般性之外，现在可以说的很少有东西在两年内是真的。

虚拟现实（VR）试图通过提供立体 3D 视角让玩家沉浸在游戏世界中。根据硬件的不同，玩家的动作也可能被检测到并作为游戏中的动作。VR 需要为每只眼睛渲染单独的场景视图，为了避免晕动，通常会以更高的帧率为目标（例如 90 fps）。

到目前为止，大多数虚拟现实设备都是与现有游戏机相连的显示器，如 PC（Oculus Rift 和 Vive）、控制台（PlayStation VR）或手机（Gear VR）。在撰写本文时，公司开始发布基于移动处理器的独立 VR 产品，其性能与高端手机大致相似。

增强现实（AR）使用半透明显示器将计算机生成的元素添加到现实世界中。尽管微软在 2016 年初发布了一个开发工具包，但消费者版本尚未推出。Magic Leap 于 2018 年发布了他们的产品，但需求有限。增强现实也可能指使用手机摄像头并在捕获的图像中添加计算机生成元素的游戏。从这个意义上讲，例如《口袋妖怪 Go》[150]被认为是一款增强现实游戏，但不需要专业硬件。

虽然 VR 游戏的视觉呈现可能是非传统的，但游戏逻辑很少如此。大多数商业游戏引擎都支持VR，通过相机在移动设备上支持AR，并在产品发布时提供硬件 AR 支持。VR 和 AR 游戏在设计上非常相似，不需要不寻常的 AI 算法。这些平台是否开辟了新的设计可能性还有待观察。这些平台是否会成为该行业的重要组成部分还有待观察。

## 2.4 人工智能引擎

当我刚进入这个行业时，游戏大多是从头开始构建的。有些代码是从以前的项目中拖出的，有些代码是重新编写和重用的，但大多数都是新的。少数公司使用相同的基本代码编写多个游戏，只要游戏的风格和类型相似。例如，LucasArts 的 SCUMM 引擎是一个逐渐发展的游戏引擎，用于为许多点击式冒险游戏提供动力。

从那时起，游戏引擎变得无处不在，成为构建多个游戏的一致技术平台。低级例程（如与操作系统对话、加载纹理、模型文件格式等）在所有游戏中共享，一组工具可用于各种游戏（如 2D 图形、3D 图形、网络），最后提供接口以在顶部添加特定于游戏的代码。最初，这些发动机属于个别公司，但随着时间的推移，只有最大的公司才能负担得起保持发动机最新的费用。现在，大型开发人员授权商业引擎是很常见的。

人工智能的发展方式也发生了变化。最初，AI 是为每个游戏编写的，有时是为每个角色编写的。现在，人们越来越倾向于使用通用的人工智能程序，这些程序要么内置在游戏引擎中，要么作为商业插件获得许可，要么由开发人员在内部创建和重用。这允许关卡编辑器、游戏设计师或技术艺术家设计单个角色。引擎结构是固定的，每个角色的 AI 以适当的方式组合了组件。本书中描述的算法通过图形前端向非专业人员公开。例如，拖动框和行允许任何人创建有限状态机（第 5.3 节）或行为树（第 5.4 节）。

因此，构建游戏引擎涉及构建可以轻松重用、组合和以有趣的方式应用的 AI 工具。为了支持这一点，我们需要一个在多种类型中都有意义的 AI 结构。

### 2.4.1 AI 引擎的结构

根据我的经验，一般的人工智能系统需要一些基本的设施。它们符合图 2.1 中给出的 AI 模型。

首先，我们必须有两类基础设施：一类是管理人工智能行为的通用机制（决定何时运行哪种行为等），另一类是将信息输入人工智能的世界接口系统。每种人工智能算法都需要遵守这些机制。

其次，我们必须有一种方法，将人工智能想要做的任何事情转化为屏幕上的行动。它由运动和动画控制器的标准接口组成，可以将“拉杆1”或“悄悄地走到位置x、y”等请求转化为行动。

第三，标准行为结构必须作为两者之间的桥梁。几乎可以保证，你需要为每个新游戏编写一到两个AI算法。让所有的AI都符合相同的结构，这将极大地帮助实现这一点。新代码可以在游戏运行时进行开发，新的AI可以在准备就绪时简单地替换占位符行为。

所有这些都需要提前考虑。在你深入学习人工智能编码之前，结构需要到位。本书的第三部分讨论了支持技术，这是在 AI 引擎中实现的第一件事。然后，个人技术可以发挥作用。

游戏引擎为你做了一些，但不是全部。每个引擎都有自己的机制来确保你的代码运行，通常是以你应该从中派生的基类的形式。但你可能需要提供更细粒度的控制：并非每个角色都需要在每一帧中运行 AI。它们还提供了调度动画的标准机制，但角色移动的频率较低。它们可能提供基本的工具来确定哪个角色知道什么（例如内置的视线或视锥检查），但对于任何更复杂的东西都需要自定义实现。除非你打算使用非常简单的技术，否则你需要创建一些基础设施，可能还需要在编辑器中创建一些工具来支持它。

我不打算在整本书中强调这种结构。我将介绍一些可以独立工作的技术，所有的算法都是相当独立的。对于演示或简单的游戏，只需使用该技术就足够了。但是，良好的 AI 结构有助于促进重用，并减少调试和开发时间。

### 2.4.2 工具问题

完整的 AI 引擎将有一个中央 AI 算法池，可以应用于许多角色。因此，特定角色的AI定义将由数据（可能包括某些脚本语言的脚本）组成，而不是编译代码。数据指定了字符是如何组合在一起的：将使用哪些技术，以及这些技术是如何参数化和组合的。

这些数据必须来自某个地方。数据可以手动创建，但这并不比每次手动编写 AI 更好。灵活的工具确保艺术家和设计师能够以简单的方式创建内容，同时允许在没有手动帮助的情况下将内容插入游戏。这些通常在游戏引擎编辑器中创建为自定义模式：用于设置角色决策规则的工具，或用于标记战术位置或要避开的地方的关卡叠加。

公开搜索工具的需求对人工智能技术的选择有其自身的影响。很容易建立总是以相同方式行事的行为。转向行为（在第 3 章中介绍）就是一个很好的例子：它们往往非常简单，很容易参数化（具有角色的物理能力），并且不会因角色而异。

在角色需要评估特殊情况的情况下，使用具有许多条件的行为会更加困难。第 5 章中涵盖的许多内容都是这样操作的。基于树（决策树、行为树）的那些更容易在视觉上表示。另一方面，基于规则的系统需要定义复杂的匹配规则。当这些在工具中得到支持时，它们通常看起来像程序代码，因为编程语言是表达它们的最自然的方式。

### 2.4.3 把它们放在一起

AI 引擎的最终结构可能如图 2.2 所示。数据在工具（建模或关卡编辑器）中创建，然后打包在游戏中使用。加载关卡后，游戏 AI 行为将根据关卡数据创建，并在 AI 引擎中注册。在游戏过程中，主游戏代码调用 AI 引擎来更新行为，从世界界面获取信息，并最终将其输出应用于游戏数据。

所使用的特定技术在很大程度上取决于所开发游戏的类型。在这本书中，我们将看到许多不同流派的各种技巧。当你开发游戏 AI 时，你需要采取混合搭配的方法来获得你想要的行为。这本书的最后一部分对此给出了一些提示；它着眼于主要类型游戏的人工智能是如何一块一块地组合在一起的。

# 第 II 部分 技术

# 第 4 章 寻路

游戏角色通常需要在他们的关卡中移动。有时，这种运动是由开发商设定的，比如警卫可以盲目遵循的巡逻路线，或者狗可以随意游荡的小围栏区域。固定路由很容易实现，但如果一个对象被推到路上，很容易被愚弄。自由漫游的角色可能会显得漫无目的，很容易陷入困境。

更复杂的角色事先不知道他们需要移动到哪里。实时战略游戏中的单位可能会在任何时候被玩家命令到地图上的任何一点，隐形游戏中的巡逻警卫可能需要移动到最近的报警点以呼叫增援，平台游戏可能需要对手使用可用平台追赶玩家穿越深渊。

对于这些角色中的每一个，人工智能必须能够计算出一条合适的路线，穿过游戏关卡，从现在的位置到达目标。我们希望路线是明智的，尽可能短或快（如果你的角色从厨房穿过阁楼走到休息室，这看起来不太明智）。

这就是寻路，有时也称为路径规划，它在游戏AI中无处不在。

在我们的游戏 AI 模型中（图 4.1），寻路位于决策和移动之间的边界。通常，它只是用来计算在哪里实现目标；目标由人工智能的另一部分决定，探路者只是想出如何到达那里。为了实现这一点，它可以嵌入到运动控制系统中，这样只有在需要规划路线时才会调用它。这在关于运动算法的第 3 章中进行了讨论。

但寻路也可以放在驾驶座上，决定去哪里以及如何到达那里。我将介绍一种寻路变体，即开放目标寻路，它可用于计算路径和目的地。

绝大多数游戏使用基于 A* 算法的寻路解决方案。虽然它高效且易于实现，但 A* 不能直接处理游戏级别的数据。它要求游戏级别以特定的数据结构表示：有向非负加权图。

本章介绍了图数据结构，然后介绍了 A* 算法的老兄弟 Dijkstra 算法。尽管 Dijkstra 在战术决策中比在寻路中更常用，但它是 A* 的一个更简单的版本，因此我们将在这里介绍完整的 A* 算法。

由于图形数据结构不是大多数游戏自然表示其关卡数据的方式，我们将详细研究将关卡几何转换为寻路数据所涉及的知识表示问题。最后，我们将看看基本 A* 算法的几十种有用变体中的少数几种。

## 4.4 世界表示

到目前为止，我假设寻路发生在由节点和具有成本的连接组成的图上。这是寻路算法所知道的世界，但游戏环境不是由节点和连接组成的。

为了将你的游戏关卡压缩到探路者中，你需要做一些转换——从地图的几何形状和角色的移动能力到图形的节点和连接，以及对它们进行估值的成本函数。

对于每个寻路世界表示，我们必须将游戏级别划分为与节点和连接相对应的链接区域。实现这一目标的不同方式称为划分方案。每个分割方案都有三个重要的属性，我们将依次考虑：量化/定位、生成和有效性。

您可能还对第 12 章“工具和内容创建”感兴趣，该章介绍了如何由级别设计器或自动过程创建寻路数据。在一个完整的游戏中，世界表示的选择与你的工具链和技术实现问题一样重要。

#### 量化和本地化

由于寻路图将比实际游戏级别更简单，因此需要一些机制将游戏中的位置转换为图中的节点。例如，当一个角色决定要到达一个开关时，它需要能够将自己的位置和开关的位置转换为图节点。这个过程被称为量化。

同样，如果角色沿着探路者生成的路径移动，它需要将计划中的节点转换回游戏世界的位置，以便正确移动。这被称为本地化。

图4.22：两个较差的量化表明，一条路径可能不可行

#### 生成

将连续空间划分为区域和连接以进行寻路的方法有很多。有几种标准方法经常使用。每种方法都是手动（手动进行划分）或算法。

当然，理想情况下，我们希望使用可以自动运行的技术。另一方面，手动技术通常会产生最佳效果，因为它们可以针对每个特定的游戏级别进行调整。

用于手动技术的最常见的划分方案是 Dirichlet 域。最常见的算法方法是平铺图、可见性点和导航网格。其中，导航网格和可见性点通常会被增强，以便在一些用户监督下自动生成图形。

#### 有效性

如果计划告诉角色沿着连接从节点a移动到节点B，那么角色应该能够执行该移动。这意味着，无论角色在节点A的哪个位置，它都应该能够到达节点B的任何一点。如果A和B周围的量化区域不允许这样做，那么寻路者可能已经创建了一个无用的计划。

如果两个连接区域中的所有点都可以相互到达，则划分方案是有效的。在实践中，大多数划分方案都不强制执行有效性。如图 4.22 所示，有效性可以有不同的水平。

在图的第一部分，这个问题还不算太糟糕。“避开墙壁”算法（见第3章）很容易解决这个问题。在具有相同算法的第二幅图中，它是终端。使用给出第二个图的除法方案是不明智的。使用第一种方案会导致更少的问题。不幸的是，分界线很难预测，容易处理的无效性与病理性只有很小的区别。

了解每个划分方案创建的图的有效性属性非常重要；至少它对可以使用的角色移动算法的类型有重大影响。

那么，让我们来看看游戏中使用的主要划分方案。

### 4.4.1 瓷砖图

基于平铺的关卡，以二维（2D）等距图形的形式，一度无处不在，现在大多出现在独立游戏中。然而，瓷砖还远没有死。虽然严格来说不是由瓷砖组成的，但大量游戏使用网格来放置三维（3D）模型。图形的底层仍然是一个规则的网格。例如，《堡垒之夜：大逃杀》[111]等游戏将其建筑和结构放置在严格的网格上，以使玩家的建筑与它们无缝连接。

这样的网格可以简单地转换为基于图块的图形。大多数实时战略（RTS）游戏仍然广泛使用基于图块的图形，许多户外游戏使用基于高度和地形数据的图形。

基于平铺的关卡将整个世界划分为规则的、通常是正方形的区域（尽管在基于回合制的战争模拟游戏中偶尔会看到六边形区域）。



## 4.5 改进 A*

A* 具有很好的启发式，是一种非常有效的算法。即使是简单的实现也可以在一个框架中跨数万个节点进行规划。使用其他优化可以实现更好的性能，例如我们在前面的部分中考虑的优化。

许多游戏环境是巨大的，包含数十万甚至数百万个位置。大型多人在线游戏（MMOG）的规模可能还要大几百倍。虽然可以在这种规模的环境中运行 A* 算法，但它会非常慢，并占用大量内存。结果也不太实际。如果一个角色试图在 MMOG 中在城市之间移动，那么告诉它如何避开五英里外道路上的一块小巨石的路线就太过分了。使用分层寻路可以更好地解决这个问题。

通常，需要快速连续地制定许多不同的计划：例如，整个军队可能需要规划穿过战场的路线。其他技术，如动态寻路，可以提高重新规划的速度，许多 A* 变化极大地减少了寻找路径所需的内存量，但会牺牲一些性能。

本章的其余部分将详细介绍其中的一些问题，并尝试介绍可能的不同 A* 变体。

## 4.6 分层寻路

分层寻路计划的方式与人大致相同。我们首先计划一个课程概述路线，然后根据需要进行改进。高层概述路线可能是“要到达后停车场，我们将走下楼梯，走出前大厅，绕过大楼的侧面”，或者“我们将穿过办公室，走出防火门，沿着防火梯走下去”。对于更长的路线，高层计划将更加抽象：“要到达伦敦办公室，我们将去机场，坐飞机，降落后叫出租车。”

路径的每个阶段都将由另一个路线计划组成。例如，要到达机场，我们需要知道路线。这条路线的第一步可能是上车。这反过来可能需要一个前往后方停车场的计划，而这反过来又需要一个绕过办公桌并离开办公室的计划。

这是一种非常有效的寻路方法。首先，我们规划抽象路线，迈出该计划的第一步，找到一条路线来完成它，以此类推，直到我们可以实际移动的水平。在初步的多层次规划之后，我们只需要在完成上一段后规划路线的下一部分。当我们到达楼梯底部，在去停车场的路上（从那里到伦敦办公室），我们计划穿过大厅的路线。当我们到达我们的车时，我们已经完成了更抽象计划的“上车”阶段，我们可以计划“开车去机场”阶段。

每个级别的计划通常很简单，我们在很长一段时间内分割寻路问题，只在当前位完成时执行下一位。



图4.37：分层节点

### 4.6.1 层次寻路图

为了能够在更高级别上进行路径查找，我们仍然可以使用 A* 算法及其所有优化。为了支持分层寻路，我们需要更改图数据结构。

# 第 5 章 决策

问一个游戏玩家关于游戏人工智能的问题，他们会想到决策：角色决定做什么的能力。执行这个决定（动作、动画等）是理所当然的。

事实上，决策通常是构建优秀游戏人工智能所需努力的一小部分。大多数游戏使用简单的决策系统：状态机和行为树。基于规则的系统较为罕见，但很重要。

近年来，人们对更复杂的决策工具表现出了极大的兴趣，如模糊逻辑和神经网络。尽管在一些高调的游戏中有显著的用途（通常伴随着大量的营销宣传），但开发人员并没有急于接受这些技术。很难让他们正常工作。

决策是我们人工智能模型的中间部分（图 5.1），但尽管有本章的名字，我们也将介绍战术和战略人工智能中使用的许多技术。这里的所有技术都适用于单角色和多角色决策。

本章将介绍各种各样的决策工具，从可以在几分钟内实现的非常简单的机制到需要更复杂但可以支持更丰富行为的综合决策工具。在本章末尾，我们将看看决策的输出以及如何采取行动。

图 5.1：人工智能模型

## 5.1 决策概述

尽管有许多不同的决策技术，但我们可以把它们都看作是以同样的方式行事。

角色处理一组信息，用于生成它想要执行的动作。决策系统的输入是角色所拥有的知识，输出是动作请求。知识可以进一步细分为外部知识和内部知识。外部知识是角色对周围游戏环境的了解：其他角色的位置、关卡的布局、是否投掷了开关、噪音的方向等等。内部知识是关于角色内部状态或思维过程的信息：它的健康状况、最终目标、几秒钟前它在做什么等等。

通常，相同的知识可以驱动本章中的任何算法。一些内部数据是算法本身特有的（状态机需要保存角色当前所处的状态，例如，面向目标的行为需要知道其当前目标是什么）。算法本身控制着可以使用哪种内部知识（无论是存储目标、状态、计划还是概率），尽管它们并不限制这些知识在游戏中所代表的内容。

相应地，算法的行为可以通过两种方式影响游戏：它们可以请求一个改变角色外部状态的动作（如投掷开关、发射武器、进入房间），也可以改变算法的内部状态（如采用新目标或调整概率）。见图 5.2。

图 5.2：决策示意图

根据定义，内部状态的变化对玩家来说不太明显。同样，一个人的精神状态的变化是不可见的，除非他们采取行动。但在大多数决策算法中，内部状态是完成大部分工作的地方。改变可能对应于改变角色对玩家的看法，改变其情绪状态，或采用新的目标。同样，算法通常会以算法特有的方式执行这些内部更改，而外部动作可以以每种算法相同的形式生成。

AI 可用的知识的格式和数量取决于游戏的要求。知识表示与大多数决策算法有着内在的联系。尽管我们将在第 11 章中考虑一些广泛适用的机制，但很难完全概括知识表示。

另一方面，可以更一致地对待行动。我们将在本章末尾回到表示和执行操作的问题。

## 5.2 决策树

决策树快速、易于实现且易于理解。它们是我们将要研究的最简单的决策技术，尽管对基本算法的扩展可以使它们变得非常复杂。它们被广泛用于控制角色和其他游戏内决策，如动画控制。

它们的优点是非常模块化，易于创建。我看到它们被用于从动画到复杂的战略和战术人工智能的所有领域。

尽管在当前的游戏中很少见，但决策树也可以学习，并且学习的树相对容易理解（例如，与神经网络的权重相比）。我们稍后将在第 7 章中回到这个话题。

### 5.2.1 问题

给定一组关于游戏当前状态的知识，以及一组可以执行的可能操作，我们需要请求一个适当的操作。

输入和输出之间的映射可能非常复杂。同一个动作可以用于许多不同的输入集，但一个输入值的任何微小变化都可能使一个动作显得合理和愚蠢。

我们需要一种方法，可以在一个动作下轻松地将大量输入组合在一起，同时允许重要的输入值控制输出。

### 5.2.2 算法

决策树由连接的决策点组成，也称为选择或节点。树有一个起始决定，它的根。对于每个决定，从根开始，选择一组选项中的一个。这些选择要么导致进一步的决定，要么导致最终的行动。

每个选择都是基于角色的知识做出的。因为决策树通常被用作简单快速的决策机制，所以角色通常直接指代全局游戏状态，而不是表示他们个人知道的内容。

该算法沿着树继续，在每个决策节点做出选择，直到决策过程没有更多的决策需要考虑。在树的每一片叶子上都有一个动作。当决策算法到达一个动作时，该动作会立即执行。

大多数决策树节点做出非常简单的决策，通常只有两个可能的响应。在图 5.3 中，决策与敌人的位置有关。

请注意，一个操作可以放置在多个分支的末尾。在图 5.3 中，角色将选择攻击，除非它看不到敌人或有侧翼。攻击行动出现在两片树叶上。

图 5.4 显示了已做出决策的同一决策树。算法所采取的路径被突出显示，显示了单个动作的到达，然后角色可以执行该动作。

#### 决定

树上的决定很简单。它们通常只检查一个值，不包含任何布尔逻辑（即，它们不使用 and 或 or 将测试连接在一起）。

根据角色知识中存储的值的实现和数据类型，可能会进行不同类型的测试。下表给出了一个代表性集合：

图 5.3：决策树

图 5.4：已做出决策的决策树

| 数据类型                                   | 决定                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| 布尔值                                     | 值为真                                                       |
| 枚举（即一组值，其中只有一个可能是允许的） | 匹配给定值集之一                                             |
| 数值（整数或浮点）                         | 值在给定范围内                                               |
| 3D 矢量                                    | 矢量的长度在给定范围内（例如，这可用于检查角色和敌人之间的距离） |

除了基本类型外，通常还允许自定义决策树节点查询游戏并执行任意逻辑。这使得决策树既能支持特定于游戏的逻辑，又能将更复杂的处理（如视线测试或物理预测）委托给优化和编译的代码。

#### 决策组合

决策树是高效的，因为决策通常非常简单，而那些性能较差的决策只在必要时才会被调用。每个决定只做一个测试。每个决定也可以单独测试。当需要布尔测试组合时，树结构表示这一点。

对于 AND 两个决策，它们将按顺序放置在树中。图 5.5 的第一部分展示了一个包含两个决策的树，这两个决策都需要为真才能执行操作 1。这棵树的逻辑是“如果 A 和 B，则执行动作 1，否则执行动作 2。”

对于 OR 两个决策，我们也使用连续的决策，但这两个操作是从上面的 AND 示例中交换过来的。图 5.5 的第二部分说明了这一点。如果任一测试返回 true，则执行动作 1。只有当两个测试都不通过时，才会运行操作 2。这棵树的逻辑是“如果 A 或 B，则执行动作 1，否则执行动作 2。”

图 5.5：表示 AND 和 OR 的树

这种简单决策树构建任何逻辑测试组合的能力被用于其他决策系统。我们将在第 5.8 节关于基于规则的系统的 Rete 算法中再次看到它。

#### 决策复杂性

因为决策是构建在树中的，所以需要考虑的决策数量通常比树中的决策数量少得多。图 5.6 显示了一个包含 15 个不同决策和 16 个可能操作的决策树。在算法运行后，我们看到只有四个决策被考虑过。

图 5.6：带有决策的宽决策树

决策树的构建相对简单，可以分阶段构建。最初可以实现一个简单的树，然后在游戏中测试人工智能时，可以添加额外的决策来捕捉特殊情况或添加新的行为。

#### 分支

在到目前为止的例子中，以及本章其余的大部分内容中，决策将在两个选项之间做出选择。这被称为二元决策树。没有理由不构建决策树，这样决策就可以有任意数量的选项。您还可以使用不同数量的分支做出不同的决定。

想象一下，在军事设施中有一个警卫角色。警卫需要根据基地的当前警报状态做出决定。此警报状态可能是一组状态之一：例如“绿色”、“黄色”、“红色”或“黑色”。使用上述简单的二元决策树，我们必须构建图5.7中的树来做出决策。

图 5.7：深度二元决策树

相同的值（警报状态）可以检查三次。如果我们订购支票，让最有可能的州排在第一位，这就不会有太大问题。即便如此，决策树可能必须多次执行相同的工作才能做出决定。

我们可以允许我们的决策树在每个决策点都有几个分支。有了四个分支，相同的决策树现在看起来如图 5.8 所示。

图 5.8：具有四个分支的扁平决策树

这种结构更平坦，只需要一个决定，而且显然更有效。尽管有明显的优势，但更常见的是只使用二元决策的决策树。出于几个原因：

1. 多个分支的底层代码通常简化为一系列二进制测试（例如，类 C 语言中的 if 语句），因此，尽管决策树在多个分支下更简单，但运行的是相同的底层代码，其速度通常没有显著差异；
2. 大多数使用决策树的常见学习算法都要求它们是二进制的；
3. 最重要的是，二元决策可以简化实现和工具支持。

你可以用二叉树做任何你可以用更复杂的树做的事情，所以每个决策都坚持两个分支已经成为惯例。我使用过的大多数（尽管不是全部）决策树系统都使用了二元决策。但归根结底，这是一个实施偏好的问题。

### 5.2.3 伪代码



## 5.3 状态机

通常，游戏中的角色会以一组有限的方式行事。他们将继续做同样的事情，直到一些事件或影响使他们改变。例如，《光环：战斗进化》[91]中的圣约战士会站在岗位上，直到它注意到玩家，然后它会切换到攻击模式，进行掩护和射击。

我们可以使用决策树来支持这种行为，我在某种程度上使用随机决策来实现这一点。然而，在大多数情况下，使用为此目的设计的技术更容易：状态机。

状态机是最常用于此类决策的技术，与脚本（见第 12 章第 13.3 节）一起，仍然构成游戏中使用的大多数决策系统。

状态机考虑了周围的世界（如决策树）和它们的内部构成（它们的状态）。

#### 基本状态机

在状态机中，每个字符占据一个状态。通常，行动或行为与每个状态都有关联。因此，只要角色保持这种状态，它就会继续执行相同的操作。

国家通过过渡联系在一起。每个转换都会从一个状态转换到另一个状态，即目标状态，并且每个转换都有一组相关的条件。如果游戏确定满足转换条件，则角色将状态更改为转换的目标状态。当满足转换的条件时，它被称为触发，当转换后进入新状态时，它就被触发了。

图 5.13：一个简单的状态机

图 5.13 显示了一个简单的状态机，有三个状态：站岗、战斗和逃跑。请注意，每个状态都有自己的一组转换。

本章中的状态机图基于统一建模语言（UML）状态图格式，这是整个软件工程中使用的标准符号。状态显示为弯曲的角框。过渡是箭头线，由触发它们的条件标记。条件放在方括号内。

图 5.13 中的实心圆只有一个没有触发条件的过渡。转换指向状态机首次运行时将进入的初始状态。

您不需要深入了解 UML 来理解本章。如果你想了解更多关于 UML 的信息，我建议你在网上搜索教程或查阅参考书，如[48]。

在决策树中，始终使用相同的决策集，并且可以通过树在任何时候执行任何操作。在状态机中，只考虑从当前状态的转换，因此并非每个动作都能在任何特定时间到达：只有当前状态及其邻居。

#### 有限状态机

在游戏 AI 中，任何具有这种结构的状态机通常被称为有限状态机（FSM）。本节和以下部分将介绍一系列功能越来越强大的状态机实现，所有这些实现通常都被称为 FSM。

这导致了与非游戏程序员的混淆，对他们来说，FSM 一词更常用于特定类型的简单状态机。计算机科学中的FSM通常是指用于解析文本的算法。编译器使用 FSM 将输入代码标记为编译器可以解释的符号。

#### 游戏 FSM

基本的状态机结构非常通用，允许任何数量的实现。我见过几十种实现游戏 FSM 的不同方法，很少有两个开发人员使用完全相同的技术。这使得很难提出一种单一的算法作为“状态机”算法。

在本节后面，我将描述 FSM 的一系列不同实现风格，但我将只介绍一种主要算法，该算法因其灵活性和实现的简洁性而被选中。

### 5.3.1 问题

我们想要一个通用的系统，支持具有任何类型转换条件的任意状态机。状态机将符合上述结构，并且一次只占用一个状态。

### 5.3.2 算法

为了实现这一点，我们使用了一个通用的状态接口，该接口可以实现为包含任何特定的代码。状态机跟踪一组可能的状态，并记录它所处的当前状态。除了每个状态，还维护一系列转换。每个转换都是一个通用接口，可以在适当的条件下实现。它只是向状态机报告它是否被触发。

在每次迭代（通常是每一帧）中，都会调用状态机的更新函数。这将检查是否触发了从当前状态的任何转换。触发的第一个转换计划启动。然后，该方法从当前活动状态编译要执行的操作列表。如果触发了转换，则启动转换。

转换的触发和触发的这种分离允许转换也有自己的动作。通常，从一个状态转换到另一个状态也需要执行一些操作。在这种情况下，触发的转换可以将它需要的操作添加到状态返回的操作中。

### 5.3.3 伪代码

状态机保存状态列表，并指示哪一个是当前状态。它具有用于触发和触发转换的更新功能，以及返回一组要执行的操作的功能：



### 5.3.8 分层状态机

就其本身而言，一个状态机是一个强大的工具，但它可能很难表达一些行为。一个常见的困难来源是“报警行为”

想象一下，一个服务机器人在清洁地板的设施周围移动。它有一个状态机允许它这样做。它可能会四处寻找掉落的物体，找到后捡起一个，然后把它送到垃圾压实机。这可以使用正常的状态机简单地实现（见图 5.14）。

不幸的是，机器人可能会电量不足，因此它必须赶紧跑到最近的电源点充电。无论它当时在做什么，它都需要停止，当它再次充满电时，它需要从停止的地方继续。例如，充电时间可能会让玩家悄悄溜走，或者让玩家禁用该区域的所有电力，从而禁用机器人。

让当前动作重新充电是报警机制的一个例子：中断正常行为以响应重要事件的东西。在状态机中表示这一点会导致状态数量加倍。

在一级警报的情况下，这不是问题，但如果我们想让机器人在走廊发生战斗时躲起来，会发生什么。如果它的隐藏本能比它的加油本能更重要，那么它将不得不中断加油来躲藏。战斗结束后，它需要在停止的地方继续加油，之后它将继续之前所做的一切。对于两个级别的警报，我们将有 16 个状态。

与其将所有逻辑组合到一个状态机中，我们可以将其分成几个。每个报警机制都有自己的状态机，以及原始行为。它们按层次结构排列，因此只有当更高级别的状态机没有响应其警报时，才会考虑下一个状态机停机。

图 5.15：标准状态机中的报警机制

图 5.15 显示了一种报警机制，与上图完全对应。

在这些图中，我显示了一个状态机在另一个内部，以表示一个分层状态机（图 5.16）。实心圆再次表示机器的启动状态。当首次进入复合状态时，内部带有 H* 的圆圈表示应进入哪个子状态。

图5.16：机器人的分层状态机

如果已经进入复合状态，则返回上一个子状态。因此，H* 节点被称为“历史状态”。

关于为什么在 H 后面有一个星号的细节，以及 UML 状态图的一些其他变幻莫测之处，都超出了本章的范围。有关更多详细信息，请参阅 Pilone 和 Pitman[48]。

我们添加嵌套状态，而不是使用单独的状态来跟踪非报警状态。即使我们正在加油，我们仍然会跟踪清洁状态机的状态。加油结束后，清洁状态机将从停止的地方继续。

实际上，我们同时处于多个状态。我们可能在报警机制中处于“加油”状态，同时我们在清洁机中也处于“拾取物体”状态。因为有一个严格的等级制度，所以永远不会混淆哪个状态会胜出：等级制度中最高的状态总是处于控制之中。

为了实现这一点，我们可以简单地在程序中安排状态机，以便一个状态机在需要时调用另一个。因此，如果加油状态机处于“清理”状态，它会调用清理状态机并要求它采取行动。当它处于“加油”状态时，它直接返回加油动作。

虽然这会导致代码有点难看，但它会实现我们的场景。然而，大多数分层状态机都支持层次结构级别之间的转换，为此我们需要更复杂的算法。

例如，让我们扩展我们的机器人，这样它就可以在没有要收集的物体的情况下做一些有用的事情。它将利用这个机会去充电，而不是站在那里等待电池耗尽，这是有道理的。新的状态机如图5.17所示。

图5.17：具有跨层次转换的层次状态机

请注意，我又添加了一个转换：从“搜索”状态直接切换到“加油”状态。当没有要收集的对象时，会触发此转换。因为我们直接脱离了这种状态，内部状态机不再有任何状态。当机器人加油并且报警系统转换回清洁时，机器人将没有从哪里取车的记录，因此它必须从初始节点再次启动状态机（“搜索”）。

#### 问题

我们想要一个支持分层状态机的状态机系统的实现。我们还希望在机器的不同层之间进行过渡。

#### 算法

在分层状态机中，每个状态本身都可以是一个完整的状态机。因此，我们依靠递归算法来处理整个层次结构。与大多数递归算法一样，这可能很难遵循。这里介绍的最简单的实现是双重棘手的，因为它在层次结构的不同点上反复出现。我鼓励您将本节中的非正式讨论和示例与下一节中的伪代码一起使用，以了解它是如何工作的。

系统的第一部分返回当前状态。结果是一个状态列表，从层次结构的最高到最低。状态机要求其当前状态返回其层次结构。如果状态是终端状态，则返回自身；否则，它将返回自身，并从其当前状态向其添加层次结构。

在图 5.18 中，当前状态为[状态L，状态A]。

图 5.18：层次结构中的当前状态

分层状态机的第二部分是它的更新。在原始状态机中，每个状态机都以初始状态启动。因为状态机总是从一个状态转换到另一个状态，所以永远不需要检查是否没有状态。层次结构中的状态机不能处于任何状态；他们可能有一个跨层次的转变。那么，更新的第一阶段是检查状态机是否有状态。如果没有，它应该进入初始状态。

接下来，我们检查当前状态是否有要执行的转换。层次结构中更高级别的转换始终具有优先级，如果超级状态有一个触发子状态，则不会考虑子状态的转换。

触发的转换可能是三种类型之一：它可能是向层次结构当前级别的另一个状态的转换，也可能是向层级结构中更高级别的状态的转换或向层级结构中低级别的状态转换。显然，过渡需要提供更多的数据，而不仅仅是一个目标状态。我们允许它返回相对水平；目标状态在层次结构中向上或向下有多少步。

我们可以简单地在层次结构中搜索目标状态，而不需要明确的级别。虽然这将更灵活（我们不必担心级别值错误），但这将花费更多的时间。一个混合但全自动的扩展可以在离线后搜索层次结构并存储所有适当的级别值。

因此，触发的转换有一个级别为零（状态处于同一级别）、一个级别大于零（状态在层次结构中较高）或一个级别小于零（状态位于层次结构中较低）。根据级别所属的类别，它的行为不同。

如果该级别为零，则该转换是正常的状态机转换，可以使用有限状态机中使用的相同算法在当前级别执行。

如果级别大于零，则需要退出当前状态，在此级别上不需要做任何其他事情。返回退出操作，并向调用更新函数的人指示转换尚未完成。我们将重新启动退出行动，过渡未完成，通过过渡的级别更高。此级别值在返回时减少1。正如我们将看到的，更新函数将返回到层次结构中的下一个最高状态机。

如果级别小于零，则当前状态需要转换到层次结构中当前级别上目标状态的祖先。此外，该州的每个孩子也需要做同样的事情，直到最终目的地州的水平。为了实现这一点，我们使用了一个单独的函数 `updateDown`，它递归地执行从目标状态级别到当前级别的转换，并在此过程中返回任何退出和进入操作。然后，过渡就完成了，不需要传递。所有累积的动作都可以返回。

因此，如果当前状态发生了触发的转变，我们已经涵盖了所有可能性。如果它没有触发的转换，那么它的动作取决于当前状态本身是否是状态机。如果不是，并且当前状态是普通状态，那么我们可以像以前一样返回与处于该状态相关的操作。

如果当前状态是一个状态机，那么我们需要给它机会来触发任何转换。我们可以通过调用其更新函数来实现这一点。更新功能将自动处理任何触发器和转换。正如我们上面看到的，较低级别的火灾过渡可能会使其目标状态处于较高级别。update函数将返回一个操作列表，但它也可能返回一个转换，即它正在传递层次结构，但尚未触发。

如果收到这样的转换，则检查其级别。如果该级别为零，则应在此级别上执行转换。这一过渡受到尊重，就像它是当前状态的常规过渡一样。如果级别仍然大于零（它永远不应该小于零，因为此时我们正在传递层次结构），那么状态机应该继续传递它。与以前一样，它通过退出当前状态并返回以下信息来实现这一点：退出操作、当前状态更新函数提供的任何操作、仍在等待中的转换以及转换的级别（减一）。

如果当前状态的更新函数没有返回转换，那么我们可以简单地返回它的操作列表。如果我们处于层次结构的顶层，那么仅凭列表就可以了。如果我们处于较低的位置，那么我们也处于一个状态中，所以我们需要将我们所处状态的操作添加到我们返回的列表中。

幸运的是，这个算法至少很难解释，也很难实现。为了了解它是如何工作的以及为什么工作的，让我们通过一个例子来说明。

#### 例子

图 5.19 显示了我们将用作示例的分层状态机。

图5.19：分层状态机示例

为了澄清每个示例返回的操作，我们将说 S-entry 是状态 S 的一组进入操作，类似地，S-active 和 S-exit 用于活动和退出操作。在转换中，我们使用相同的格式：1-actions 用于与转换 1 相关的操作。

如果你浏览这些例子，可能会让人感到困惑。如果你在算法上遇到问题，我敦促你一步一步地使用上图和下一节的伪代码。

假设我们从状态 L 开始，没有转换触发器。我们将转换到状态 [L，A]，因为 L 的初始状态是 A。更新函数将返回 L-active 和 A-entry，因为我们停留在 L 中，只输入 A。

现在假设转换 1 是唯一触发的。顶级状态机将检测不到有效的转换，因此它将调用状态机 L 查看是否有任何转换。L发现其当前状态（A）具有触发转换。转换 1 是当前级别的转换，因此它在 L 内处理，不会传递到任何地方。A转换为B，L的更新函数返回 A-exit、1-actions、B-entry。顶级状态机接受这些操作并添加自己的活动操作。因为我们一直呆在 L 状态，所以最后一组行动是 A-exit, 1-actions, B-entry, L-active。当前状态为[L，B]。

从该状态开始，转换 4 被触发。顶级状态机看到转换 4 被触发，因为这是一个顶级转换，所以可以立即执行。转换导致状态 M，相应的动作是 L-exit, 4-actions, M-entry。目前的状态是[M]。请注意，L 仍然保留着处于状态B的记录，但由于顶级状态机处于状态 M，因此目前不使用此记录。

我们将通过转换 5 以正常方式从状态 M 转到状态 N。该过程与前面的示例和非分层状态机完全相同。现在，转换 6 被触发。因为这是一个零级转换，顶级状态机可以立即执行它。它转换到状态 L 并返回动作 N-exit、6-actions、L-entry。但现在 L 在 B 状态的记录很重要；我们最终又回到了 [L，B] 状态。在我们的实现中，我们不返回 B-entry 操作，因为我们之前离开状态L时没有返回 B-exit 操作。这是我们个人的喜好，并非一成不变。如果你想退出并重新进入状态 B，那么你可以修改你的算法，在适当的时候返回这些额外的操作。

现在假设从状态 [L，B] 转换 3 触发。顶级状态机找不到触发器，因此它将调用状态机 L 查看是否有触发器。L 发现状态 B 有一个触发的转换。这种转变有一个层次；它的目标在层次结构中高一级。这意味着 B 状态正在退出，这意味着我们不能在这个层面上尊重过渡。我们返回 B-exit，以及未完成的转换和级别减 1（即零，表示下一级需要处理转换）。因此，控制返回到顶级更新函数。它看到L返回了一个未完成的转换，级别为零，因此它尊重它，以正常的方式转换到状态N。它将L返回的动作（即 B-exit）与正常的转换动作相结合，给出了最后一组动作：B-exit、L-exit、3-actions、N-entry。请注意，与我们的第三个例子不同，L 不再跟踪它位于状态 B 的事实，因为我们已从该状态转换出去。如果我们触发转换 6 以返回状态 L，那么将进入状态 L 的初始状态（A），就像第一个例子一样。

我们的最后一个例子涵盖了级别小于零的转换。假设我们通过转换 7 从状态 N 移动到状态 M。现在我们触发转换2。顶级状态机查看其当前状态（M），并发现转换 2 已触发。它的级别为 -1，因为它在层次结构中下降了一个级别。因为它的级别为 -1，所以状态机调用 updateDown 函数来执行递归转换。updateDown 函数从包含最终目标状态（C）的状态机（L）开始，要求它在其级别执行转换。状态机L反过来要求顶级状态机在其级别执行转换。顶层状态机从状态 M 更改为状态 L，返回 M-exit、L-entry 作为相应的操作。控制返回到状态机 L 的 updateDown 函数。状态机L检查它当前是否处于任何状态（不是，因为我们在上一个例子中离开了状态 B）。它将其动作（C-entry）添加到顶级计算机返回的动作中。然后，控制返回到顶级状态机的更新函数：降序转换已完成；它将转换的动作添加到结果中，并返回 M-exit、2-actions、L-entry、C-entry。

如果状态机L仍然处于状态 B，那么当 L 的 updateDown 函数被调用时，它将从 B 转换到 C。它将在从顶级状态机接收到的操作中添加 B-exit 和 C-entry。

#### 伪代码



### 5.3.9 结合决策树和状态机

转换的实现与决策树的实现有很多相似之处。这并非巧合，但还可以更进一步。

决策树是匹配一系列条件的有效方法，这在状态机中用于匹配转换。

我们可以通过用决策树替换状态的转换来结合这两种方法。树的叶子，而不是像以前那样是动作，是向新状态的过渡。

一个简单的状态机可能如图 5.20 所示。

图 5.20：具有决策树转换的状态机

菱形符号也是 UML 状态图格式的一部分，表示决策。在 UML 中，决策和转换之间没有区别，决策本身通常也没有标签。

在这本书中，我用它们所执行的测试来标记决策，这对我们的需求更清晰。

该图显示，当处于“警报”状态时，哨兵只有一个可能的转换：通过决策树。它很快就能确定哨兵是否能看到玩家。如果哨兵看不到玩家，则转换结束，不会达到新的状态。如果哨兵能够看到玩家，那么决策树就会根据玩家的距离做出选择。根据此选择的结果，可能会达到两种不同的状态：“发出警报”或“防御”。只有通过进一步的测试（与玩家的距离）才能达到后者。

为了在没有决策节点的情况下实现相同的状态机，需要图 5.21 中的状态机。请注意，现在我们有两个非常复杂的条件，都必须评估相同的信息（到玩家的距离和到报警点的距离）。如果该条件涉及耗时的算法（例如我们示例中的视线测试），那么决策树的实现将明显更快。

图 5.21：没有决策树转换的状态机

#### 伪代码



## 5.4 行为树

行为树已成为创建 AI 角色的流行工具。《光环2》[92]是最早详细描述行为树使用的高调游戏之一，从那时起，更多的游戏也纷纷效仿。

它们是人工智能中已经存在了一段时间的许多技术的综合：分层状态机、调度、计划和动作执行。他们的优势来自他们以一种易于理解和非程序员易于创建的方式交织这些问题的能力。然而，尽管它们越来越普遍，但在行为树中有些事情很难做好，而且它们并不总是决策的好解决方案。

行为树与分层状态机有很多共同之处，但行为树的主要构建块不是状态，而是任务。任务可以很简单，比如在游戏状态中查找变量的值，或者执行动画。

任务被组成子树来表示更复杂的动作。反过来，这些复杂的动作可以再次组合成更高层次的行为。正是这种可组合性赋予了行为树力量。因为所有任务都有一个共同的接口，并且在很大程度上是自包含的，所以它们可以很容易地构建成层次结构（即行为树），而不必担心层次结构中每个子任务是如何实现的。

#### 任务类型

行为树中的任务都具有相同的基本结构。它们有一些 CPU 时间来做自己的事情，当它们准备就绪时，它们会返回一个状态代码，指示成功或失败（在这个阶段，布尔值就足够了）。一些开发人员使用一组更大的返回值，包括当意外出错时的错误状态，或者需要更多时间与调度系统集成的状态。

虽然各种任务都可以包含任意复杂的代码，但如果每个任务都可以分解为可以有效组合的最小部分，则可以提供最大的灵活性。这尤其是因为，虽然行为树作为一种编程习惯用法非常强大，但当与图形用户界面（GUI）结合使用以编辑树时，行为树真的会大放异彩。这样，设计师、技术艺术家和关卡设计师就有可能创造复杂的人工智能行为。

在这个阶段，我们的简单行为树将由三种任务组成：条件、动作和复合。

条件测试游戏的某些属性。可以进行接近度测试（角色是否在敌人的 X 个单位内？）、视线测试、角色状态测试（我健康吗？我有弹药吗？）等等。每种测试都需要作为单独的任务来实现，通常需要一些参数化，这样它们就可以很容易地重复使用。如果满足条件，则每个条件返回成功状态代码，否则返回失败。

动作会改变游戏的状态。可以有用于动画、角色移动、改变角色内部状态（例如，休息会提高健康）、播放音频样本、让玩家参与对话以及使用专门的AI代码（如寻路）的动作。就像条件一样，每个操作都需要有自己的实现，并且在您的引擎中可能有大量的实现。大多数时候，动作会成功（如果有可能失败，最好在角色开始尝试动作之前使用条件进行检查）。但是，如果无法完成，则可以编写失败的操作。

如果从我们之前关于决策树和状态机的讨论中，条件和动作看起来很熟悉，那么它们应该很熟悉。它们在每种技术中都扮演着相似的角色（我们将在本章稍后看到更多具有相同功能的技术）。然而，行为树的关键区别在于为所有任务使用一个通用接口。这意味着任意的条件、动作和组可以组合在一起，而不需要知道行为树中还有什么。

条件和动作都位于树的叶子节点上。大多数分支由 Composite 节点组成。顾名思义，这些任务跟踪一组子任务（条件、动作或其他复合任务），它们的行为基于其子任务的行为。与动作和条件不同，通常只有少数复合任务，因为只有少数不同的分组行为，我们就可以构建非常复杂的行为。

对于我们的简单行为树，我们将考虑两种类型的复合任务：选择器和序列。这两者都轮流运行他们的每个孩子的行为。当子行为完成并返回其状态代码时，Composite 决定是继续通过其子行为，还是停止并返回一个值。

当其中一个子选择器成功运行时，它将立即返回成功状态代码。只要它的孩子们失败了，它就会继续尝试。如果它的子项完全用完，它将返回失败状态代码。

当其中一个子序列失败时，序列将立即返回失败状态代码。只要它的孩子们成功了，它就会继续前进。如果它没有孩子了，它会成功的回来。

选择器用于选择一组可能成功的操作中的第一个。选择器可能代表一个想要达到安全的角色。可能有多种方法可以做到这一点（寻找掩护、离开危险区域、呼叫支援）。选择器将首先尝试寻找掩护；如果失败，它将离开该地区。如果成功了，它就会停止——也没有必要要求支援，因为我们已经解决了角色达到安全的目标。如果我们用尽了所有选项而没有成功，那么选择器本身就失败了。

选择器任务如图 5.22 所示。首先，选择器尝试一个代表攻击玩家的任务；如果成功了，就完成了。如果攻击任务失败，Selector 节点将继续尝试嘲讽动画。作为最后的退路，如果其他一切都失败了，这个角色只能威胁地盯着看。

图 5.22：行为树中的选择器节点示例

序列表示需要执行的一系列任务。在前面的例子中，我们的每个到达安全动作都可能由一个序列组成。为了找到掩护，我们需要选择一个掩护点，移动到它，当我们在射程内时，播放一个滚动动画到达它后面。如果序列中的任何一个步骤失败，那么整个序列都失败了：如果我们无法到达所需的掩护点，那么我们就没有到达安全地带。只有当序列中的所有任务都成功时，我们才能认为序列作为一个整体是成功的。

图 5.23 显示了使用 Sequence 节点的一个简单示例。在此行为树中，第一个子任务是检查是否存在可见敌人的条件。如果第一个子任务失败，则序列任务也将立即失败。如果第一个子任务成功，那么我们就知道有一个可见的敌人，序列任务继续执行下一个子任务，即转身，然后是正在运行的任务。然后，序列任务将成功终止。

图 5.23：行为树中的序列节点示例

#### 一个简单的例子

我们可以使用前面示例中的任务来构建一个简单但功能强大的行为树。本例中的行为树表示一个试图进入玩家所在房间的敌方角色。

我将分阶段构建树，以强调如何逐步创建和扩展树。这种细化行为树的过程是其吸引力的一部分，因为简单的行为可以被粗略化，然后根据游戏测试和额外的开发资源进行细化。

我们的第一阶段，图 5.24，显示了由单个任务组成的行为树。这是一个移动动作，可以使用我们的发动机提供的任何转向系统来执行。

图5.24：最简单的行为树

为了运行这个任务，我们给它 CPU 时间，然后它移动到房间里。当然，在《半条命》之前，这是进入房间的最先进的人工智能，但现在在射击游戏中不会很受欢迎！然而，这个简单的例子确实说明了一点。当你使用行为树开发人工智能时，你只需要一个简单的行为就可以让它工作。

在我们的情况下，敌人太愚蠢了：玩家可以简单地关上门，迷惑来袭的敌人。

所以，我们需要把树做得更复杂一些。在图 5.25 中，行为树由一个选择器组成，它可以尝试两种不同的东西，每种都是一个序列。在第一种情况下，它使用条件任务检查门是否打开；然后它进入房间。在第二种情况下，它移动到门前，播放动画，打开门，然后移动到房间里。

图5.25：具有复合节点的行为树

让我们思考一下这个行为树是如何运行的。想象一下，门是开着的。当给定 CPU 时间时，选择器会尝试其第一个子项。那个孩子是由穿过敞开的门的序列任务组成的。该条件检查门是否打开。是的，所以它会带来成功。因此，Sequence 任务继续执行下一个子任务——穿过门。这和大多数动作一样，总是成功的，所以整个序列都是成功的。回到顶层，选择器从它尝试的第一个子节点收到了成功状态代码，因此它不会同时尝试另一个子节点：它会立即返回成功。

当门关上时会发生什么？与之前一样，选择器会尝试其第一个子对象。该序列尝试条件。然而，这一次，条件任务失败了。序列不会打扰继续；一次失败就足够了，所以它会以失败的形式回归。在顶层，选择器不会因故障而受到困扰；它只是转移到下一个孩子身上。于是，角色移到门口，打开门，然后进入。

这个例子显示了行为树的一个重要特征：序列中的条件任务就像编程语言中的 IF 语句。如果不满足条件，则序列将不会超过该点。如果序列依次放置在选择器中，那么我们就会得到 If ELSE 语句的效果：只有当第一个子项的条件不满足时，才会尝试第二个子项。在伪代码中，这棵树的行为是：

```python
if isLocked(door):
    moveTo(door)
    open(door)
    moveTo(room)
else:
    moveTo(room)
```

伪代码和图表显示，我们在这两种情况下都使用了 final move 操作。这没什么不对的。在本节的后面，我们将看看如何有效地重用现有的子树。现在值得说的是，我们可以重构我们的行为树，使其更像更简单的伪代码：

```python
if isLocked(door):
    moveTo(door)
    open(door)
    moveTo(room)
```

结果如图 5.26 所示。请注意，它比以前更深；我们不得不在树上添加另一层。虽然有些人确实喜欢从源代码的角度思考行为树，但这并不一定能让你了解如何创建简单或高效的树。

图5.26：更复杂的重构树

在本节的最后一个例子中，我们将处理玩家锁门的可能性。在这种情况下，角色仅仅假设门可以打开是不够的。相反，它需要先尝试一下门。图 5.27 显示了处理这种情况的行为树。请注意，用于检查门是否锁上的条件不会出现在我们检查门是否关闭的同一点上。大多数人不能仅仅通过看门来判断门是否锁着，所以我们希望敌人走到门前，尝试一下，然后在门锁着的情况下改变行为。在这个例子中，我们让角色肩扛着门。

图5.27：最低可接受敌人的行为树

我不会详细介绍此行为树的执行过程。请随意自己穿过它，并确保您了解如果门打开、关闭和锁定，它将如何工作。

在这个阶段，我们可以开始看到行为树的另一个共同特征。它们通常由序列和选择器的交替层组成。只要我们只有 Sequence 和 Selector 这两个 Composite 任务，就始终可以用这种方式编写树。

([1]：其原因可能并不明显。如果你考虑一棵树，其中一个选择器有另一个子选择器，那么它的行为将与子选择器的子选择器插入父选择器时完全相同。如果其中一个孙子成功归来，那么它的父母也会立即成功归来，祖父母也是如此。对于其他Sequence任务中的Sequence任务也是如此。这意味着没有功能上的理由让两个级别具有相同类型的复合任务。然而，使用另一种分组方式可能存在非功能性原因，例如将相关任务分组在一起，以便更清楚地了解整个树试图实现的目标。)

即使在本节稍后我们将看到的其他类型的 Composite 任务中，Sequence 和 Selector 仍然是最常见的，因此这种交替结构非常常见。

我们可能正处于敌人进入房间的行为在当代游戏中可以接受的地步。我们在这里还可以做更多的事情。我们可以增加额外的检查，看看是否有窗户可以砸碎。我们可以添加一些行为，让角色使用手榴弹来炸门，我们可以让它捡起物体来砸门，我们还可以让它假装离开，躺着等待玩家出现。

无论我们最终做什么，扩展行为树的过程与我在这里展示的完全一样，让角色 AI 在每个中间阶段都可以玩。

#### 行为树与反应式规划



### 5.4.7 行为树的局限性

在过去的十年里，行为树从无到有，在流行游戏引擎的良好工具支持下，成为游戏人工智能的核心技术。不可避免地，在任何炒作中，很容易将它们视为游戏人工智能中几乎所有问题的解决方案。值得谨慎一点。了解行为树不擅长什么与了解它们擅长什么一样重要。

我们已经看到了行为树的一个关键局限性。在表示我们在上一节中遇到的基于状态的行为时，它们相当笨拙。并非所有基于国家的行为都会导致问题。如果你的角色纯粹因为动作的成功或失败而在行为类型之间转换（例如，当他们不能做某事时会发疯），那么行为树就可以很好地工作。但是，如果你有一个需要应对外部事件的角色——例如，打断巡逻路线突然躲藏或发出警报——或者一个在弹药看起来很低时需要切换策略的角色，那么它们就会变得更加麻烦。我并不是说这些行为不能在行为树中实现，只是这样做不太习惯。

由于行为树使得从状态的角度进行思考和设计变得更加困难，因此仅基于行为树的人工智能往往会避免这些行为。如果你看一个由艺术家或关卡设计师创建的行为树，他们往往会避免角色性格或警报行为的明显变化。这是一种耻辱，因为这些线索简单而强大，有助于提高人工智能的水平。

当然，我们可以构建一个混合系统，其中角色有多个行为树，并使用状态机来确定他们当前正在运行的行为树。使用我们上面看到的行为树库的方法，这提供了两全其美的效果。不幸的是，它也给人工智能作者和工具链开发人员增加了相当大的额外负担，因为他们现在需要支持两种创作：状态机和行为树。

另一种方法是在行为树中创建行为类似于状态机的任务——检测重要事件并终止当前子树以开始另一个。然而，这只是增加了创作难度，因为我们仍然需要为人工智能作者构建一个系统来参数化这些相对复杂的任务。

行为树本身就是游戏人工智能的一大胜利，开发人员仍将在多年内探索其潜力。只要他们在推进最新技术，我怀疑在开发人员和工具供应商尝试自己的方法时，就不会就如何最好地避免这些限制达成强烈共识。

## 5.5 模糊逻辑

到目前为止，我们做出的决定都是经过深思熟虑的。条件和决定是真是假，我们没有质疑分界线。模糊逻辑是一组旨在处理灰色区域的数学技术。

想象一下，我们正在为一个在危险环境中移动的角色编写人工智能。在有限状态机方法中，我们可以选择两种状态：“谨慎”和“自信”。当角色谨慎时，它会慢慢溜走，留心麻烦。当角色自信时，它会正常行走。当角色在关卡中移动时，它将在两种状态之间切换。这可能看起来很奇怪。我们可能会认为这个角色变得越来越勇敢，但直到它突然停止爬行，像什么都没发生过一样走着，这才显示出来。

模糊逻辑使我们能够模糊谨慎和自信之间的界限，给我们一个完整的信心水平范围。使用模糊逻辑，我们仍然可以做出“谨慎时慢慢走”这样的决定，但“缓慢”和“谨慎”都可以包括一系列程度。

### 5.5.1 警告

模糊逻辑已被应用于多种游戏中，适用于许多决策问题。它值得在这本书和你的技术工具箱中占有一席之地。然而，你应该知道，由于合理的原因，模糊逻辑在主流学术人工智能社区中因概率可以成功建模的问题而受到很大程度的质疑。

你可以在 Russell 和 Norvig[54]中阅读更多细节，但执行摘要是，使用概率来表示任何类型的不确定性总是更好的。更具体地说，已经证明，如果你玩任何一种零和博彩游戏，那么一个不基于概率论做出决定的玩家最终可能会赔钱。原因是，除了概率论之外，任何其他不确定性理论的缺陷都有可能被对手利用。

模糊逻辑在游戏中比概率论更受欢迎，部分原因是它更容易翻译简单的规则（例如“谨慎时慢慢走”）。部分原因是人们认为使用概率方法可能很慢。随着贝叶斯网和其他图形建模技术的出现，这两种技术都不是问题。虽然我不会在本书中明确介绍贝叶斯网络，但我们将研究各种其他相关方法，如马尔可夫系统。

### 5.5.2 模糊逻辑简介

本节将快速概述理解本章技术所需的模糊逻辑。模糊逻辑本身是一门庞大的学科，具有许多微妙的特征，我没有足够的空间来涵盖该理论的所有有趣和有用的部分。如果你想要一个广泛的基础，我推荐 Buckley 和 Eslami[7]，这是一篇关于这个主题的广泛使用的文本，现在可能很难找到或很昂贵。有关更新的文本，请参见[52]。

#### 模糊集合

在传统逻辑中，我们使用“谓词”的概念，即某物的性质或描述。例如，一个角色可能饿了。在这种情况下，“饥饿”是一个谓词，每个字符要么有，要么没有。同样，一个字符可能会受到伤害。感觉不到有多受伤；每个字符都有或没有谓词。可能有一些潜在的数字（例如，命中点），但会有一些分界线来确定一个字符是否有谓词。

我们可以将这些谓词视为集合。谓词所应用的一切都在集合中，其他一切都在外面。

这些集合被称为经典集合，传统逻辑可以用它们来表述。

模糊逻辑通过给谓词一个值来扩展谓词的概念。因此，一个角色可能会受到伤害，例如值为 0.5，或者饥饿，值为 0.9。伤害值为 0.7 的角色将比伤害值为 0.3 的角色受到更大的伤害。因此，不是属于一个集合或被排除在外，而是所有东西都可以部分属于这个集合，有些东西可以比其他东西属于更多。

在模糊逻辑的术语中，这些集合称为模糊集合，数值称为隶属度。因此，饥饿值为 0.9 的字符属于隶属度为 0.9 的饥饿集。

对于每个集合，模糊集合中的某个事物的隶属度为 1。它相当于经典集合的成员资格。同样，值 0 表示完全在模糊集之外的东西。当我们看看下面的逻辑规则时，你会发现当集合成员资格为0或1时，传统逻辑的所有规则仍然有效。

理论上，我们可以使用任何数值范围来表示成员资格的程度。但在本书中，我将使用从 0 到 1 的一致值来表示隶属度，这与几乎所有模糊逻辑文本一样。然而，使用整数（例如，在 0 到 255 的范围内）实现模糊逻辑是很常见的，因为整数算术比使用浮点数更快、更准确。

无论我们使用什么值，在模糊逻辑之外都没有任何意义。一个常见的错误是将值解释为概率或百分比。偶尔，这样看待它会有所帮助，但应用模糊逻辑技术的结果很少与应用概率技术的结果相同，这可能会令人困惑。

#### 多个集合的成员资格

任何事物都可以同时成为多个集合的成员。例如，一个角色可能既饿又受伤。这对于经典集和模糊集都是一样的。

通常，在传统逻辑中，我们有一组互斥的谓词。例如，一个角色不能既受伤又健康。在模糊逻辑中，情况已不再如此。一个角色可以是受伤的，也可以是健康的，可以是高大的，也可能是矮小的，它可以是自信和好奇的。角色在每组中只会有不同程度的成员资格（例如，它可能是 0.5 伤害和 0.5 健康）。

互斥的模糊等价是成员度之和为 1 的要求。因此，如果伤害和健康字符集是互斥的，那么伤害 0.4 和健康 0.7 的字符是无效的。同样，如果我们有三个互斥的集合——自信、好奇和恐惧——一个自信 0.2 和好奇 0.4 的角色将被恐惧 0.4。

模糊决策的实现很少强制执行这一点。大多数实现允许任何成员值集，依靠模糊化方法（见下一节）给出一组近似等于 1 的成员值。在实践中，稍微偏离的值对结果的影响很小。

#### 模糊化

模糊逻辑只适用于模糊集的隶属度。由于这不是大多数游戏保存数据的格式，因此需要进行一些转换。将常规数据转化为隶属度称为模糊化；毫不奇怪，将其逆转是去模糊化。

##### 数字模糊化

最常见的模糊化技术是将数值转换为一个或多个模糊集的成员。例如，游戏中的角色可能有多个命中点，我们想将其转化为“健康”和“伤害”模糊集的成员。

这是通过成员功能实现的。对于每个模糊集，一个函数将输入值（在我们的例子中为命中点）映射到隶属度。图 5.38 显示了两个隶属函数，一个用于“健康”集，一个适用于“伤害”集。

图 5.38：成员功能

从这组函数中，我们可以读取成员值。标记了两个字符：字符 A 为健康 0.8，伤害 0.2，而字符 B 为健康 0.3，伤害 0.7。请注意，在这种情况下，已经选择了隶属函数，这样它们产生的值总是加起来为 1。

可以依赖于相同输入值的不同成员函数的数量没有限制，它们的值不需要加起来为 1。

##### 其他数据类型的模糊化

在游戏环境中，我们通常还需要模糊布尔值和枚举。最常见的方法是为每个相关集存储预先确定的成员值。

一个角色可能有一个布尔值来指示它是否携带了强大的工件。成员函数有一个存储值，用于 true 和 false，并选择适当的值。如果模糊集直接对应于布尔值（例如，如果模糊集是“拥有强大的工件”），则成员值将为 0 和 1。

枚举值也有相同的结构，其中有两个以上的选项：每个可能的值都有一个预先确定的存储成员值。例如，在武术格斗游戏中，角色可能拥有一组腰带中的一条，表明他们的实力。为了确定“可怕的战士”模糊集中的隶属度，可以使用图 5.39 中的隶属函数。

图 5.39：枚举值的成员函数

#### 反模糊化

在应用了我们需要的任何模糊逻辑后，我们得到了一组模糊集的隶属度值。为了将其转化为有用的数据，我们需要使用去模糊技术。

我们在上一节中看到的模糊化技术相当明显，几乎无处不在。不幸的是，没有相应明显的去模糊方法。有几种可能的去模糊技术，对于哪种是最好的，目前还没有明确的共识。它们都有相似的基本结构，但在效率和结果稳定性方面有所不同。

解模糊涉及将一组成员值转换为单个输出值。输出值几乎总是一个数字。它依赖于为输出值提供一组成员函数。我们正试图逆转模糊化方法：找到一个输出值，该值将导致我们知道的成员值。

这种情况很少直接发生。在图 5.40 中，模糊集“爬行”、“行走”和“跑步”的隶属度值分别为 0.2、0.4 和 0.7

图 5.40：不可能的去模糊

隶属函数表明，如果我们将运动速度输入模糊化系统，则没有可能的值来给出这些隶属值。然而，我们希望尽可能接近，每种方法都以不同的方式解决问题。

值得注意的是，用于描述去模糊方法的术语存在混淆。你经常会发现以相同名称描述的不同算法。成员价值的程度缺乏任何真正的意义，这意味着不同但相似的方法往往会产生同样有用的结果，从而鼓励混淆和方法的多样性。

##### 使用最高会员资格

我们可以简单地选择具有最大隶属度的模糊集，并在此基础上选择输出值。在上面的例子中，“run”成员值为0.7，因此我们可以选择一个代表跑步的速度。

选择了四个共同点：函数返回 1 的最小值（即，对于集合的成员资格，最小值为 1）、最大值（以相同的方式计算）、两者的平均值和函数的平分线。函数的平分线是通过积分隶属函数曲线下的面积并选择平分该面积的点来计算的。图 5.41 显示了单个成员函数的这一点以及其他方法。

图 5.41：最大值的最小值、平均平分线和最大值

虽然集成过程可能很耗时，但它可以执行一次，可能是离线。然后，结果值始终用作该集合的代表点。

图 5.41 显示了该示例的所有四个值。

这是一种非常快速的技术，易于实现。不幸的是，它只提供了粗略的去模糊处理。成员值为 0 爬行、0 行走、1 跑步的角色将具有与 0.33 爬行、0.33 行走、0.34 跑步的角色完全相同的输出速度。

##### 基于成员资格的混合

绕过这一限制的一个简单方法是根据其相应的隶属度混合每个特征点。因此，具有 0 爬行、0 行走、1 跑步的角色将使用跑步集的特征速度（以我们上面看到的任何一种方式计算：最小值、最大值、平分线或平均值）。一个爬行 0.33、行走 0.33、奔跑 0.34 的角色的速度将由下式给出

$$ 0.33 v_{creep} + 0.33 v_{walk} + 0.4 v_{run} $$

其中 $v_{creep}$ 是爬行的特征速度，其他变量同样适用于行走和跑步。

唯一的附带条件是确保乘法因子是标准化的。有可能有一个 0.6 爬行、0.6 行走、0.7 跑步的角色。简单地将成员值乘以特征点可能会使输出速度比运行速度更快。

当混合最小值时，产生的去模糊通常被称为“最大值最小”方法，或“最大值左侧”（LM）。同样，最大值的混合可以称为最大值的最大值（有时也称为 LM！）或最大值的右值。平均值的混合可以称为最大值平均值（MoM）。

不幸的是，一些引用假设我们只有一个成员函数参与去模糊化。在这些引用中，您可能会发现用于表示未混合表单的相同方法名。去模糊化方法之间的命名通常是一个猜测的问题。

在实践中，它们叫什么并不重要，只要你能找到一个适合你的。

##### 重心

这种技术也被称为面积质心。此方法考虑所有成员值，而不仅仅是最大的成员值。

首先，每个成员函数都会根据其对应集合的成员值进行裁剪。因此，如果一个角色的游程隶属度为 0.4，则隶属度函数将裁剪到 0.4 以上。图 5.42 显示了一个功能和整套功能。

图 5.42：裁剪成员函数，裁剪所有成员函数

然后通过依次整合每个裁剪区域来找到裁剪区域的质心。该点用作输出值。质心点在图中标记。

使用这种方法需要时间。与面积平分线法不同，我们不能离线进行积分，因为我们事先不知道每个函数将被裁剪到什么级别。由此产生的积分（通常是数字，除非隶属函数有已知的积分）可能需要时间。

值得注意的是，这种重心法虽然经常使用，但与电气和电子工程师协会（IEEE）模糊控制规范中同名的方法不同。IEEE 版本在计算其重心之前不会裁剪每个函数。因此，每个隶属函数的结果点都是恒定的，因此在我们的分类中属于混合点方法。

##### 选择去模糊方法

尽管重心方法在许多模糊逻辑应用中受到青睐，但它的实现相当复杂，可能会使添加新的隶属函数变得更加困难。混合点方法提供的结果通常同样好，计算速度也快得多。

它还支持加速实现，从而消除了使用成员函数的需要。您可以直接指定值，而不是计算每个函数的代表点。然后可以以正常方式混合这些值。在我们的例子中，我们可以指定爬行速度为每秒 0.2 米，步行为每秒 1 米，跑步为每秒 3 米。然后，基于归一化隶属度，去模糊化只是这些值的加权和。

##### 去模糊为布尔值

为了得到布尔输出，我们使用一个模糊集和一个截止值。如果集合的隶属度小于截止值，则输出被视为假；否则，它被认为是真的。

如果几个模糊集需要对决策做出贡献，那么它们通常会使用模糊规则（见下文）组合成一个集，然后可以将其解模糊为输出布尔值。

##### 将解模糊为枚举值

对枚举值进行解模糊的方法取决于不同的枚举是形成一个序列，还是它们是独立的类别。我们之前的武术腰带示例形成了一个系列：腰带是有序的，而且它们的力量是按照递增的顺序排列的。相比之下，一组枚举值可能表示要执行的不同操作：角色可能正在决定是吃饭、睡觉还是看电影。这些不能轻易地按任何顺序排列。

可以排序的枚举通常被解模糊为数值。每个枚举值对应于一个不重叠的数字范围。反模糊处理与任何其他数值输出完全相同，然后通过一个额外的步骤将输出放入其适当的范围，将其转换为枚举选项之一。图 5.43 显示了武术示例的实际情况：去模糊化会产生一个“威力”值，然后将其转换为适当的腰带颜色。

图 5.43：范围内枚举的解模糊

无法排序的枚举通常会通过确保模糊集对应于每个可能的选项（例如，使用模糊规则组合其他集）来进行去模糊化。可能有一个模糊集合用于“吃”，另一个用于“睡”，还有一个用于”看电影“。选择具有最高成员值的集合，并输出其相应的枚举值。

#### 结合事实

## 5.6 马尔可夫系统

模糊状态机可以同时处于多个状态，每个状态都有相关的隶属度。在模糊逻辑之外，按比例处于一组状态是有用的。尽管模糊逻辑不会为其隶属度赋予任何外部含义（它们需要被解模糊为任何有用的量），但有时直接使用状态的数值是有用的。

我们可能有一组优先级值，例如，控制一组角色中的哪一个可以带头攻击，或者一个角色可以使用数值来表示一个级别中每个狙击位置的安全性。这两个应用程序都受益于动态值。不同的角色可能会在不同的战术情况下发挥作用，或者在战斗中他们的相对健康状况会波动。狙击位置的安全性可能因敌人的位置和防护障碍物是否被摧毁而异。

这种情况经常出现，创建一个类似于状态机的算法来操纵值相对简单。然而，对于这种算法的名称还没有达成共识。最常见的是它被称为模糊状态机，使用模糊逻辑的实现和不使用的实现之间没有区别。在这本书中，我将为涉及模糊逻辑的算法保留“模糊状态机”。我们实现背后的数学是一个马尔可夫过程，所以我将把该算法称为马尔可夫状态机。请记住，这种命名法并不普遍。

在我们研究状态机之前，我将简要介绍马尔可夫过程。

### 5.6.1 马尔可夫过程

我们可以将数值状态集表示为数字向量。矢量中的每个位置对应于单个状态（例如，单个优先级值或特定位置的安全性）。该向量称为状态向量。

向量中显示的值没有限制。可以有任意数量的零，整个向量可以加起来为任何值。应用程序可以对允许的值施加自己的约束。如果这些值代表一个分布（例如，敌军在一个大陆的每个领土上所占的比例），那么它们的总和将为 1。数学中的马尔可夫过程几乎总是与随机变量的分布有关。很多文献都假设状态向量之和为 1。

状态向量中的值根据转移矩阵的作用而变化。一阶马尔可夫过程（我们将考虑的唯一过程）有一个单一的转移矩阵，可以从之前的值生成新的状态向量。高阶马尔可夫过程也考虑了早期迭代中的状态向量。

转移矩阵总是正方形的。矩阵中（i，j）处的元素表示旧状态向量中元素i与新向量中元素 j 相加的比例。马尔可夫过程的一次迭代包括使用正规矩阵乘法规则将状态向量乘以转移矩阵。结果是一个与原始状态向量大小相同的状态向量。新状态向量中的每个元素都有旧向量中每个元素贡献的分量。

#### 保守马尔可夫过程

保守的马尔可夫过程确保状态向量中的值之和不会随时间变化。这对于状态向量之和应始终固定的应用程序至关重要（例如，它表示分布，或者如果值表示游戏中某个对象的数量）。如果转移矩阵中的所有行之和为1，则该过程将是保守的。

#### 迭代过程

## 5.7 目标导向行为

到目前为止，我一直专注于反应的方法：向角色提供一组输入，行为选择适当的动作。没有欲望或目标的实现。该角色仅对输入做出反应。

当然，即使使用最简单的决策技巧，也有可能让角色看起来有目标或欲望。一个想要杀死敌人的角色会追捕一个敌人，对敌人的出现做出攻击反应，并在没有敌人的时候寻找敌人。同样的角色也可能有明显的求生欲望，在这种情况下，它会考虑自己的保护，对健康状况不佳或存在危险做出反应。底层结构可能会对输入做出反应，但角色不需要以这种方式出现。

根据我的经验，这是了解学术人工智能的人对游戏人工智能的误解。简单的技术可以让人看起来更聪明，因为游戏世界本身是有限的，设计师可以限制玩家与它互动的方式。烟雾和镜子不是侮辱，这是我们的工作方式。因为，对于玩家来说，控制角色的东西并不重要，只要它看起来是正确的。

简单的技术让我们走了很长的路。但是，我们可以使用更先进的方法来使角色在寻求目标时更加灵活。在某些游戏类型中，这是一种有用的方法。它在模拟人物游戏中尤其明显，如《模拟人生》[136]。

在这里，一次屏幕上只有几个角色。每个人都有一系列的情绪和身体参数，这些参数会随着时间的推移而变化，与环境和行为有关。玩家通常可以直接控制角色的动作，尽管角色总是能够独立行动。

在《模拟人生》这样的游戏中，游戏没有总体目标。在其他标题中，如《幽灵大师》[177]，有一个明确的目标（你试图用各种鬼魂和超自然力量把居民吓出房子）。

在这种游戏中，角色可以进行各种不同的动作。动作可能包括烧水壶、坐在沙发上或与另一个角色交谈。动作本身由录制的动画表示。

角色需要通过选择适当的动作来展示他们的情绪和身体状态。他们应该饿的时候吃饭，累的时候睡觉，孤独的时候和朋友聊天，需要爱的时候拥抱。我们可以简单地运行一个决策树，根据角色当前的情感和身体参数选择可用的动作。在《模拟人生》这样的游戏中，这将导致一个非常大的决策树。每个角色都有数百个参数化操作可供选择。

更好的方法是向角色展示一系列可能的行动，并让它选择最能满足其当前需求的行动。

这是目标导向行为（GOB），明确地寻求实现角色的内部目标。与本书中的许多算法一样，这个名字只能松散地应用。GOB 对不同的人可能意味着不同的东西，它经常被模糊地用来指任何寻求目标的决策者，或者指与这里类似的特定算法。我将把它作为一个通用术语。

在本章中，我们将从一个非常简单的 GOB 框架开始，并使用它来实现一个基于公用事业的 GOB 决策者。我稍后将描述目标导向行动计划（GOAP），这是基本 GOB 系统的扩展，可以计划一系列行动来实现其目标。

### 5.7.1 目标导向行为

目标导向行为是一个总括性术语，涵盖了考虑目标或欲望的任何技术。GOB 没有单一的技术，本章中的一些其他技术，特别是基于规则的系统，可用于创建目标寻求角色。在本节中，我们将介绍一个基于实用程序的决策系统，该系统可以根据其当前目标从一系列操作中进行选择。这是一个基于我自己为客户实现的系统，我知道其他地方也使用过类似的系统。

#### 目标

一个角色可能有一个或多个目标，也称为动机。可能有数百个可能的目标，角色当前可以有任意数量的目标处于活动状态。他们可能有吃东西、恢复健康或杀死敌人等目标。每个目标都有一个重要程度（通常称为坚持），由一个数字表示。一个具有高度坚持性的目标往往会对角色的行为产生更大的影响。

角色会努力实现自己的目标或减少坚持。有些游戏允许完全满足目标（例如杀死敌人）。其他游戏有一组固定的目标，这些目标总是存在的，当目标实现时，它们只是减少了坚持（例如，一个角色可能总是有一个“变得健康”的目标，但当他们已经健康时，坚持程度较低）。坚持的零值相当于完全满足的目标。

我在这里故意把目标和动机混为一谈。为了塑造伟大的游戏角色，目标和动机通常可以被视为同一件事，或者至少在某种程度上模糊在一起。严格来说，它们是截然不同的：动机可能会基于角色的信仰产生目标，例如（即，我们可能有一个杀死敌人的目标，其动机是为了报复我们的同事，因为我们相信敌人杀了他们）。确切的定义取决于研究人员。出于我们的目的，这是一个我们不需要这个算法的额外层，所以我将把动机和目标视为大致相同的东西，通常称之为目标。

我们可以在没有坚持值的情况下轻松实现目标，但这使得选择关注哪些目标变得更加困难。我选择使用实数而不是布尔值，因为由此产生的算法并不复杂。如果你的游戏有数千个角色和数百个目标，那么使用开/关目标并节省存储空间可能是值得的。

在《模拟人生》这样的游戏中，角色的身体和情感参数可以被解释为目标值。一个角色可能有饥饿的动机：饥饿值越高，吃东西就越成为一个紧迫的目标。

#### 行动

除了一系列目标，我们还需要一系列可能的行动供选择。这些动作可以集中生成，但它们也通常由世界上的对象生成。在《模拟人生》的世界里，水壶增加了“烧水壶”的动作，空烤箱增加了“插入生食”的动作。在动作游戏中，敌人可能会引入“攻击我”的动作，而门可能会暴露出“锁”的动作。

可用的操作取决于游戏的当前状态。空烤箱可能会在放置“插入”动作之前检查角色是否携带生食。装有生食的烤箱不允许添加更多的食物；它揭示了一种“烹饪食物”的行为。同样，如果门已经锁定，则会显示“解锁”动作，或者在允许解锁之前，可能会先显示“插入钥匙”动作。

当这些动作被添加到选项列表中时，它们会根据角色的每个动机进行评级。该评级显示了该行为对特定动机的影响程度。因此，“玩游戏机”的动作可能会大大增加幸福感，但也会降低能量。

在射击游戏中，动作更具原子性。每个行动都列出了可以实现的目标。例如，“射击”动作可以实现杀死敌人的目标，“弹簧陷阱”动作也是如此，等等。

一个行动承诺实现的目标可能还有几步之遥。例如，一块生食可能会满足饥饿感。如果角色拿起它，它不会变得不那么饿，但现在空烤箱将提供“插入”动作，再次承诺喂饱角色。同样的事情继续通过“烹饪食物”动作、“从烤箱中取出食物”动作，最后是“吃”动作。在某些游戏中，单个动作由一系列动作组成。例如，“射击”动作可能由“拔枪”、“瞄准”和“射击”等动作组成。本章末尾的动作执行部分详细介绍了这种组合动作。

### 5.7.2 简单选择

### 5.7.5 整体效用 GOAP

基于效用的 GOB 方案考虑了单一行动的影响。该行动表明了它将如何改变每个目标值，决策者使用这些信息来预测完整的一组值，从而预测之后的总体不满。

我们可以将此扩展到一系列中的多个动作。假设我们想确定四个动作的最佳顺序。我们可以考虑四个动作的所有组合，并在所有动作完成后预测不满值。最低的不满值表示应该优先采取的行动顺序，我们可以立即执行第一个行动。

这基本上就是 GOAP 的结构：我们按顺序考虑多个动作，并试图找到最符合角色长期目标的顺序。在这种情况下，我们使用不满值来指示目标是否得到实现。这是一种灵活的方法，导致了一种简单但相当低效的算法。在下一节中，我还将描述一个 GOAP 算法，该算法试图计划行动以实现单一目标。

有两个并发症使 GOAP 变得困难。首先，有大量可用的行动组合。原始的 GOB 算法在时间上为 O(nm)，但对于 k 个步骤，一个简单的 GOAP 实现在时间上将为 O(nm^k^)。对于合理数量的行动（记住《模拟人生》可能有数百种可能性），以及合理数量的向前看的步骤，这将是不可接受的漫长。我们需要使用少量的目标和行动，或者一些方法来降低这种复杂性。

其次，通过将可用操作组合成序列，我们还没有解决启用或禁用操作的问题。我们不仅需要知道行动完成后的目标是什么，还需要知道接下来可以采取哪些行动。我们无法从当前集合中查找四个动作的序列，因为当我们执行第四个动作时，我们可能无法使用它。

为了支持 GOAP，我们需要能够计算出世界的未来状态，并利用它来产生将出现的行动可能性。当我们预测一个动作的结果时，它需要预测所有的效果，而不仅仅是角色目标的变化。

为了实现这一点，我们使用了一个世界模型：世界状态的表示，可以在不改变实际游戏状态的情况下轻松更改和操纵。这可以是游戏世界的精确模型。也可以通过故意限制角色模型中允许的内容来模拟角色的信仰和知识。一个不知道桥下巨魔的角色不应该把它放在模型中。如果不对信念进行建模，角色的 GOAP 算法将发现巨魔的存在，并在其规划中加以考虑。这可能看起来很奇怪，但通常并不明显。

为每个角色存储游戏状态的完整副本可能有点过头了。除非你的游戏状态非常简单，否则通常会有数百到数万条数据需要跟踪。相反，世界模型可以实现为差异列表：模型仅在与实际游戏数据不同时存储信息。这样，如果算法需要找出模型中的某些数据，它首先会查看差异列表。如果数据不包含在那里，那么它知道它与游戏状态没有变化，并从那里检索它。

#### 算法

到目前为止，我已经描述了 GOAP 的一个相对简单的问题。GOAP 有许多不同的学术方法，它们允许更复杂的问题领域。约束（在一系列动作中不得改变的世界事物）、偏序（动作序列或动作组，可以以任何顺序执行）和不确定性（不知道动作的确切结果）等特征都增加了我们在大多数游戏中不需要的复杂性。我即将描述的算法与 GOAP 一样简单，但根据我的经验，它适用于大多数游戏应用程序。

我们从一个世界模型开始（它可以匹配世界的当前状态或代表角色的信仰）。从这个模型中，我们应该能够获得角色的可用操作列表，并且我们应该能够简单地复制模型。规划由最大深度参数控制，该参数指示向前看有多少步。

该算法创建了一个世界模型数组，其中比深度参数的值多出一个元素。随着算法的进展，这些将用于存储世界的中间状态。第一个世界模型设置为当前世界模型。它记录了其规划的当前深度，最初为零。它还跟踪到目前为止最佳的动作顺序及其导致的不适值。

该算法迭代工作，在迭代中处理单个世界模型。如果当前深度等于最大深度，则算法计算不适值，并将其与迄今为止的最佳值进行比较。如果新序列是最好的，则将其存储。

如果当前深度小于最大深度，则算法会在当前世界模型上找到下一个未考虑的动作。它将数组中的下一个世界模型设置为将动作应用于当前世界模型的结果，并增加其当前深度。如果没有更多可用操作，则当前世界模型已完成，算法将当前深度减小一个。当当前深度最终返回到零时，搜索结束。

这是一种典型的深度优先搜索技术，无需递归即可实现。该算法将深入检查所有可能的动作序列。如上所述，这是浪费，即使是轻微的问题也可能需要很长时间才能完成。不幸的是，这是保证我们得到所有可能动作序列中最好的唯一方法。如果我们准备在大多数情况下牺牲这种保证来获得相当好的结果，我们可以大大缩短执行时间。

为了加快算法的速度，我们可以使用启发式方法：我们要求永远不要考虑导致更高不适值的行为。在大多数情况下，这是一个合理的假设，尽管在许多情况下它会崩溃。人类往往满足于一时的不适，因为从长远来看，这会给他们带来更大的幸福。例如，没有人喜欢面试，但之后的工作是值得的（或者你希望如此）。

另一方面，这种方法确实有助于避免在计划中期出现一些令人讨厌的情况。回想一下之前的浴室或苏打水困境。如果我们不考虑中间的不适值，我们可能会制定一个计划，喝苏打水，经历尴尬的时刻，换衣服，最终达到合理的不适程度。人类不会这样做；他们会采取一个避免事故的计划。

为了实现这种启发式方法，我们需要在每次迭代中计算不适值并将其存储。如果不适值高于前一个深度，则可以忽略当前模型，我们可以立即减小当前深度并尝试另一个动作。

在我写这本书时构建的原型中，这导致在模拟人生般的环境中速度提高了约 100 倍，最大深度为 4，每个阶段可选择约 50 个动作。即使最大深度为 2，角色选择动作的方式也会有很大的不同（每次增加深度都会降低可信度的回报）。

#### 伪代码



### 5.7.6 有 IDA* 的 GOAP

我们的问题域由一组目标和行动组成。目标有不同的坚持程度，这使我们能够选择一个目标来追求。行动告诉我们它们实现了哪些目标。

在上一节中，我们没有一个目标；我们试图在所有可能的动作序列中找到最好的。现在我们只有一个目标，我们对实现目标的最佳动作序列感兴趣。我们需要限制我们的问题，寻找完全实现目标的行动。与之前试图尽可能减少坚持的方法（完全实现是消除所有坚持的特殊情况）相比，我们现在需要有一个明确的目标，否则 A* 就无法发挥其魔力。

在这种情况下，我们还需要定义“最佳”。理想情况下，我们希望序列尽可能短。就行动数量或行动总持续时间而言，这可能很短。如果在每个动作中使用了时间以外的资源（如魔法力量、金钱或弹药），那么我们也可以考虑这一点。与寻路一样，计划的长度可以是许多因素的组合，只要它可以表示为单个值。我们将把最终措施称为计划成本。理想情况下，我们希望找到成本最低的计划。

只有一个目标要实现，成本测量要尽量减少，我们可以使用 A* 来驱动我们的规划者。A* 在许多 GOAP 应用程序中以基本形式使用，其余大部分应用程序都对其进行了修改。我在第 4 章中已经详细介绍了 A*，所以我将避免在这里过多地介绍它的工作原理。您可以转到第 4 章，对该算法的工作原理进行更复杂的逐步分析。

#### IDA*

如果可能的动作数量很大，可能的序列数量也会很大。与任何位置的相邻点相对较少的寻路不同，在某些游戏中，在任何状态下都可能有数百个可能的操作。

此外，我们可以采取的行动数量可能没有限制。除非我们知道什么时候停止寻找，否则我们可能会继续行动数年或数十年，而无法实现我们的目标。因为目标往往无法实现，所以我们需要对序列中允许的操作数量进行限制。这相当于深度优先搜索方法中的最大深度。当使用 A* 进行寻路时，我们假设至少有一条通往目标的有效路线，因此我们允许 A* 尽可能深入地搜索以找到解决方案。最终，探路者将没有可考虑的位置，并将终止。

在 GOAP，同样的事情可能不会发生。总有一些行动需要采取，除了尝试所有可能的行动组合外，计算机无法判断目标是否无法实现。如果目标无法实现，算法将永远不会终止，但会愉快地使用越来越多的内存。我们增加了最大深度来遏制这种情况。添加此深度限制使我们的算法成为使用 A* 迭代深化版本的理想候选者。

我们在第 4 章中讨论的许多 A* 变体都适用于 GOAP。您可以使用完整的 A* 实现、节点数组 A*，甚至简化的内存限制 A*（SMA* ）。然而，根据我的经验，迭代深化 A* （IDA* ）是一个很好的选择。它处理大量的操作而不会淹没内存，并允许我们轻松限制搜索的深度。在本章的背景下，它还具有与之前的深度优先算法相似的优点。

#### 启发式

所有 A* 算法都需要一个启发式函数。启发式算法估计目标有多远。它允许算法优先考虑接近目标的动作。

我们需要一个启发式函数来估计给定世界模型距离实现目标还有多远。这可能是一件很难估计的事情，尤其是在需要长时间协调行动的情况下。即使有进展，也可能看起来没有进展。如果完全不可能创建启发式，那么我们可以使用空启发式（即总是返回估计值为零的启发式）。与寻路一样，这使得 A* 的行为与 Dijkstra 的算法相同：检查所有可能的序列。

#### 算法

IDA* 首先调用起始世界模型上的启发式函数。该值存储为当前搜索截止值。

IDA* 然后运行一系列深度优先搜索。每次深度优先搜索都会继续，直到找到一个满足其目标的序列，或者用尽所有可能的序列。搜索受到最大搜索深度和截止值的限制。如果一系列操作的总成本大于截止值，则忽略该操作。

如果深度优先搜索达到目标，则算法返回结果计划。如果搜索失败，则稍微增加截止值，并开始另一个深度优先搜索。

截止值增加到比之前搜索中发现的截止值大的最小总计划成本。

由于 IDA* 中没有 OPEN 和 CLOSED 列表，我们无法跟踪在搜索的不同点是否找到重复的世界状态。GOAP 申请往往有大量这样的重复；例如，不同顺序的动作序列通常会产生相同的结果。

我们希望避免在每次深度优先搜索中反复搜索同一组动作。我们可以使用转置表来帮助做到这一点。换位表通常用于棋盘游戏的人工智能，我们将在第9章棋盘游戏人工智能中详细介绍它们。

对于IDA*，转置表是一个简单的哈希。每个世界模型都必须能够为其内容生成一个好的哈希值。在深度优先搜索的每个阶段，该算法对世界模型进行哈希运算，并检查它是否已经在转置表中。如果是，则将其留在那里，搜索不会处理它。如果不是，则将它与用于到达那里的序列中的操作数量一起添加。

这与普通哈希表略有不同，每个哈希键有多个条目。常规哈希表可以容纳无限的数据项，但随着加载速度的增加，速度会逐渐变慢。在我们的例子中，每个哈希键只能存储一个项目。如果另一个世界模型带有相同的哈希键，那么我们可以完全处理它而不存储它，也可以启动位于其位置的世界模型。这样，我们可以保持算法的高速度，而不会增加内存使用。为了决定是否启动现有条目，我们使用了一个简单的经验法则：如果当前条目的移动次数较少，我们会替换一个条目。

图 5.45 显示了为什么这有效。世界模型A和B是不同的，但两者具有完全相同的哈希值。未标记的世界模型有自己独特的哈希值。世界模型 A 出现了两次。如果我们能避免考虑第二个版本，我们可以节省很多重复。然而，世界模型 B 首先被发现，也出现了两次。它的第二次出现发生在稍后，后续要处理的动作较少。如果要在不处理第二个 A 或第二个 B 之间做出选择，我们希望避免处理a，因为这将大大减少我们的整体工作量。

图 5.45：为什么要替换下面的转置条目

通过使用这种启发式方法，在冲突的哈希值被解决以支持更高级别的世界状态的情况下，我们在示例中得到了完全正确的行为。

#### 伪代码

### 5.7.7 气味 GOB

制作可信 GOB 的另一种方法与第 11.4 节中讨论的感官感知模拟有关。

在这个模型中，角色可以拥有的每个动机（如“吃”或“寻找信息”）都被表示为一种气味；它逐渐在游戏关卡中扩散。具有与之相关的动作的物体会发出一种混合的“气味”，每种气味代表其动作所影响的动机。例如，烤箱可能会散发出“我可以提供食物”的气味，而床可能会散发“我可以让你休息”的气味。

目标导向行为可以通过让角色追随气味来实现，因为它最关心的是实现动机。例如，一个极度饥饿的角色会跟随“我可以提供食物”的气味，找到通往炊具的路。

这种方法减少了游戏中复杂的寻路需求。如果角色有三种可能的食物来源，那么传统的 GOB 会使用探路者来查看每种食物来源的难度。然后角色会选择最方便的来源。

气味从食物的位置扩散出去。在拐角处移动需要时间，它不能穿过墙壁，它自然会找到穿过复杂关卡的路线。它也可能包括信号的强度：气味在食物来源处最大，离得越远就越淡。

为了避免寻路，角色可以在每一帧中向气味最集中的方向移动。这自然与气味到达角色的路径相反：它顺着鼻子到达目标。同样，因为气味的强度消失了，角色会自然地朝着最容易到达的源头移动。

这可以通过允许不同的源发射不同的强度来扩展。例如，垃圾食品可以发出少量的信号，而丰盛的一餐可以发出更多的信号。这样，角色会更喜欢营养较少、真正方便的食物，同时仍然努力做一顿均衡的饭。如果没有这个扩展，这个角色总是会在厨房里寻找垃圾食品。

这种“嗅觉”方法在《模拟人生》中被用来引导角色采取适当的行动。它的实现相对简单（您可以使用第 11 章“世界接口”中提供的感觉管理算法），并提供了大量逼真的行为。然而，它有一些局限性，需要修改才能在游戏中使用。

#### 复合作用

许多行动需要多个步骤。例如，烹饪一顿饭需要找到一些生食，烹饪，然后吃掉。也可以找到不需要烹饪的食物。如果角色走到炊具前，因为它没有携带任何生食而无法烹饪任何东西，那么拥有一个发出“我可以提供食物”信号的炊具是没有意义的。

这种类型的重要游戏通常结合了两种不同解决方案的元素来解决这个问题：允许更丰富的信号词汇，并使这些信号的发射取决于游戏中角色的状态。

##### 基于动作的信号

游戏中的“气味”数量可以增加，以捕捉不同的动作细微差别。对于提供生食而不是熟食的物体，可能会有不同的气味。这降低了解决方案的优雅度：角色不再能够轻易地追随他们所寻求的特定动机。它们现在有效地代表了个人行为，而不是传播代表动机的信号。有一个“我可以做生食”的信号，而不是“我可以喂你”的信号。

这意味着角色需要执行正常的 GOB 决策步骤，即确定要采取的行动，以最好地实现他们当前的目标。他们的行动选择不仅取决于他们知道的可用行动，还取决于他们在当前位置可以检测到的行动信号模式。

另一方面，该技术支持大量可能的操作，并且可以在创建新的对象集时轻松扩展。

##### 角色特定信号

另一种解决方案是确保对象只有在特定时间能够被角色使用时才会发出信号。例如，一个携带生食的角色可能会被烤箱吸引（烤箱现在发出“我可以给你食物”的信号）。如果同一个角色没有携带任何生食，那么冰箱就会发出“我可以给你食物”的信号，烤箱也不会发出任何东西。

这种方法非常灵活，可以大大减少实现复杂行动序列所需的规划量。

它有一个显著的缺点，即游戏中传播的信号现在依赖于一个特定的角色。两个角色不太可能携带完全相同的物体或能够执行完全相同的动作。这意味着每个角色都需要单独的感官模拟。当游戏中有少数动作缓慢的角色时，这不是问题（角色每几百帧才做出一次决定，感官模拟很容易被分割到许多帧上）。对于更大或更快的模拟，这是不切实际的。

## 5.8 基于规则的系统

在 20 世纪 70 年代和 80 年代初，基于规则的系统处于人工智能研究的前沿。许多最著名的人工智能程序都是用它们构建的，在它们的“专家系统”化身中，它们是最著名的AI技术，后来被最近媒体对“深度学习”的报道所取代。尽管它们以效率低、难以实现而闻名，但它们在游戏中断断续续地使用了至少 20 年。它们仍然是一种相当不常见的方法，部分原因是使用决策树或状态机几乎总是可以以更简单的方式实现类似的行为。

然而，它们确实有自己的优势，尤其是当角色需要以设计师无法轻易预料并编码到决策树中的方式对世界进行推理时。然而，基于规则的系统的最大优势在于它能够证明其推理的合理性。这有助于内容创建和调试。

基于规则的系统有一个共同的结构，由两部分组成：一个包含人工智能可用知识的数据库和一组 if-then 规则。

规则可以检查数据库，以确定是否满足其“if”条件。符合条件的规则被称为触发规则。可以选择一个触发的规则来触发，然后执行其“然后”组件（图5.46）。

图5.46：基于规则的系统示意图

这与我在状态机转换中使用的术语相同。然而，在这种情况下，规则会根据数据库的内容触发，其影响可能比导致状态转换更普遍。

许多基于规则的系统还添加了第三个组件：一个仲裁器，用于决定触发哪个规则。我们将首先介绍一个简单的基于规则的系统，以及一个常见的优化，并在本节稍后返回仲裁者。

### 5.8.1 问题

在本节中，我将演示一个基于规则的决策系统，该系统具有传统人工智能中基于规则的系统的许多典型特征。该规范非常复杂，可能比许多游戏所需的更灵活。然而，任何更简单的方法，状态机或决策树都可能是实现相同效果的更好方法。

在本节中，我将调查许多基于规则的系统实现共享的一些属性。以下算法将支持每个属性。我将使用非常宽松的语法介绍数据库的内容和规则。它仅用于说明原则。以下部分建议了可以实现的每个组件的结构。

#### 数据库匹配

### 5.8.5 规则仲裁

数据库上可能同时触发多个规则。每条规则都适用，但只有一条可以开火。在上述算法中，我假设允许触发第一条规则，不考虑其他规则。这是一个简单的规则仲裁算法：“首先适用”。只要我们的规则按照优先级顺序排列，它就可以正常工作。

一般来说，基于规则的系统中的仲裁器是一块代码，它决定当多个规则触发时触发哪些规则。仲裁有许多常见的方法，每种方法都有自己的特点。

#### 首次适用

这是迄今为止使用的算法。规则以固定顺序提供，列表中触发的第一个规则将被触发。排序强制执行严格的优先级：列表中较早的规则优先于较晚的规则。

然而，这种仲裁策略经常出现严重问题。如果规则没有更改数据库的内容，并且没有施加外部更改，则每次运行系统时，相同的规则都会继续触发。这可能是必需的（例如，如果规则指示根据数据库的内容采取什么行动），但它通常会导致无休止的重复问题。

有一个简单的扩展用于降低此问题的严重性。不应该无休止地重复的规则一旦生效就会被暂停。只有当数据库的内容发生变化时，它们的暂停才会解除。这涉及跟踪每个规则的挂起状态，并在修改数据库时将其清除。

不幸的是，每当修改数据库时清除暂停仍然可能导致同样的情况发生。如果数据库中的某些内容不断变化（如果每帧都有来自游戏世界的信息写入其中，通常会发生变化），但导致问题规则触发的数据项是稳定的，那么规则将继续触发。一些实现会跟踪规则触发的单个数据项，并暂停触发的规则，直到这些特定项发生变化。

#### 最近最少使用

链表包含系统中的所有规则。与之前一样，列表被按顺序考虑，列表中的第一个触发规则被触发。当规则触发时，它将从列表中的位置删除并添加到末尾。一段时间后，列表中包含的规则使用顺序相反，因此选择第一个触发的规则类似于选择最近最少使用的规则。

这种方法专门针对循环问题。它确保在所有规则中尽可能多地分配解雇机会。

#### 随机规则

如果触发多个规则，则随机选择一个规则并允许其触发。

与之前的算法不同，这种仲裁器需要检查每个规则，并获得所有触发规则的列表。有了这样的列表，它可以选择一个成员并启动它。以前的算法只会遍历列表，直到找到第一个触发的规则。这种仲裁方案相应地效率较低。

#### 最具体的条件

如果规则的条件很容易满足，并且数据库会定期触发它，那么它很可能是一个在很多情况下都有用的通用规则，但不是专门的。另一方面，如果一个规则有很难满足的条件，并且系统发现它会触发，那么它很可能非常适合当前的情况。因此，更具体的规则应优先于更一般的规则。

在基于规则的系统中，条件表示为布尔组合子句，子句的数量是规则特异性的良好指标。

特异性只能根据规则的结构来判断。在使用系统之前，可以计算优先级顺序，并可以按顺序排列规则。因此，仲裁器实现与第一种适用方法完全相同。我们只需要添加一个离线步骤，根据条件中的子句数量自动调整规则顺序。

#### 动态优先级仲裁

如果系统运行时优先级不变，则任何数字优先级系统都与第一种适用方法相同。我们可以简单地按照优先级递减的顺序排列规则，并运行第一个触发的规则。您会发现一些文章和书籍介绍了基于优先级的静态优先级仲裁，而在实践中，一种简单的第一适用方法是相同的。然而，如果优先级是动态的，那么它们可能是有用的。

每个规则可以根据其动作在当前情况下的重要性返回动态优先级。例如，假设我们有一个匹配“不再有健康包”的规则，并计划一个查找健康包的操作。当角色的健康状况很高时，规则可能会返回非常低的优先级。如果有任何其他规则触发，健康包规则将被忽略，因此角色将继续做它正在做的事情，只有在想不出替代方案的情况下才去寻找健康包。然而，当角色濒临死亡时，该规则会返回一个非常高的优先级：角色将停止正在做的事情，去寻找健康包以生存。

我们可以使用几个规则来实现动态优先级（例如，一个规则用于“没有更多健康包和低健康”，一个用于“没有其他健康包和高健康”）。然而，使用动态优先级可以使规则逐渐变得更重要，而不是突然成为最高优先级。

仲裁器检查所有规则，并编译一个触发规则的列表。它请求列表中每个规则的优先级，并选择要触发的最高值。

与随机规则选择一样，这种方法涉及在决定触发哪个规则之前搜索所有可能的规则。它还添加了一个方法调用，这可能涉及规则在数据库中搜索信息以指导其优先级计算。这是这里描述的五种仲裁算法中最灵活但最耗时的一种。

### 5.8.7 RETE

Rete 算法是人工智能行业标准，用于将规则与数据库进行匹配。它不是周围最快的算法；有几篇论文详细介绍了更快的方法。但是，由于专家系统具有商业价值，它们往往不会提供完整的实现细节。⁶（[6]：你也应该小心专有算法，因为许多算法都有专利。仅仅因为一个算法被发布并不意味着它没有专利。即使你从头开始编写源代码，你最终也可能不得不为你的实现支付许可费。我不是律师，所以如果你有任何疑问，我建议你去见知识产权律师。）

大多数商业专家系统都是基于 Rete 的，我在游戏中看到的一些更复杂的基于规则的系统使用基于 Rete 匹配算法的方法。这是一个相对简单的算法，为更复杂的优化提供了基本的起点。

#### 算法

该算法通过在单个数据结构中表示所有规则的模式来工作：Rete。Rete 是一个有向无环图 ⁷（[7]：Rete 只是网络的一个花哨的解剖学名称。）（有关此结构的完整描述，请参阅第 4 章第 4.1 节的寻路图）。图中的每个节点表示一个或多个规则中的单个模式。图中的每条路径代表一条规则的完整模式集。在每个节点上，我们还将与该模式匹配的所有事实的完整列表存储在数据库中。

图 5.48 显示了以下规则的 Rete 的一个简单示例：

图 5.48: 一个 Rete

## 5.9 黑板架构

黑板系统本身并不是一种决策工具。它是一种协调多个决策者行动的机制。

个人决策系统可以以任何方式实现：从决策树到专家系统，甚至到学习工具，如我们将在第7章中遇到的神经网络。正是这种灵活性使黑板架构具有吸引力。

在人工智能文献中，黑板系统通常庞大而笨重，需要大量的管理代码和复杂的数据结构。因此，他们在游戏AI程序员中名声不佳。与此同时，许多开发人员实现了使用相同技术的人工智能系统，而没有将其与“黑板架构”一词联系起来

### 5.9.1 问题

我们希望能够协调几种不同技术的决策。每种技术都可能对下一步做什么提出建议，但只有在他们合作的情况下才能做出最终决定。

例如，我们可能有一种专门针对敌方坦克的决策技术。在选定要射击的坦克之前，它无法发挥作用。使用另一种人工智能来选择射击目标，但这种人工智能本身无法进行射击。同样，即使选择了目标坦克，我们也可能无法处于可以射击的位置。目标AI需要等到路线规划AI能够移动到合适的射击点。

我们可以简单地将AI的每一部分放在一个链中。目标选择器AI选择目标，运动AI移动到射击位置，弹道学AI计算射击解。这种方法很常见，但不允许信息以相反的方向传递。如果弹道学AI计算出它无法进行精确射击，那么瞄准AI可能需要计算一个新的解决方案。另一方面，如果弹道学人工智能可以计算出一次射击，那么甚至不需要考虑运动人工智能。显然，无论前方有什么物体，都不会影响炮弹的轨迹。

我们希望有一种机制，每个人工智能都可以自由通信，而不需要明确设置所有通信渠道。

### 5.9.2 算法

黑板系统的基本结构有三个部分：一组不同的决策工具（称为黑板专家）、一块黑板和一个仲裁器。如图 5.54 所示。

图5.54：黑板架构

黑板是任何专家都可以用来读写的记忆区域。每个专家都需要用大致相同的语言读写，尽管黑板上通常会有一些不是每个人都能理解的信息。

每个专家看黑板，决定黑板上是否有他们可以使用的东西。如果有的话，他们要求允许暂时使用粉笔和黑板擦。当他们获得控制权时，他们可以进行一些思考，从黑板上删除信息，并根据自己的需要写下新的信息。不久之后，专家将放弃控制权，让其他专家尝试。

仲裁员每次都会选择哪位专家进行控制。专家们需要有某种机制来表明他们有有趣的话要说。仲裁器一次选择一个，并赋予它控制权。通常，没有或只有一个专家想要控制，也不需要仲裁者。

该算法在迭代中工作：

1.专家们看着董事会，表示他们的兴趣。
2.仲裁员选择一位专家进行控制。
3.专家做了一些工作，可能是修改黑板。
4.专家自愿放弃控制权。

仲裁器使用的算法可能因实现而异。我将在这里描述的简单而常见的方法要求专家们以数字坚持值的形式表明他们认为自己有多有用。然后，仲裁员可以简单地选择具有最高坚持值的专家。在平局的情况下，随机选择一名专家。

#### 提取动作

建议的行动可以由专家写在黑板上，就像他们写任何其他信息一样。在迭代结束时（或者如果系统运行时间更长，则进行多次迭代），可以删除黑板上的动作，并使用本章末尾的动作执行技术执行。

通常，一个行动在经过适当思考之前，就可以在黑板上提出建议。在我们的坦克示例中，目标专家可能会在板上发布“向15号坦克开火”的动作。如果算法在这一点上停止，那么行动将在弹道和运动专家没有机会达成一致的情况下进行。

一个简单的解决方案是将潜在操作与一组协议标志一起存储。黑板上的行动只有在所有相关专家都同意的情况下才能执行。这不一定是系统中的每个专家，而只是那些能够找到不执行行动的理由的人。

在我们的例子中，“向15号坦克开火”行动将有一个协议槽：弹道学专家的协议槽。只有弹道学专家批准，才能采取行动。弹道学专家可能会拒绝批准，而是删除该动作或添加一个新的动作“进入15号坦克的射击位置”。由于“向15号坦克开火”动作仍在黑板上，弹道主义专家可以等到到达射击位置后再同意。

### 5.9.3 伪代码

### 5.9.6 其他东西是黑板系统

当我第一次描述黑板系统时，我说它有三个部分：一个包含数据的黑板，一组读写黑板的专家（以任何方式实现），以及一个控制哪个专家获得控制权的仲裁器。然而，它并不是唯一拥有这些组件的。

#### 规则系统

基于规则的系统具有这三个元素中的每一个：它们的数据库包含数据，每个规则都像专家一样——它可以从数据库中读取和写入数据，并且有一个仲裁器来控制触发哪个规则。规则的触发类似于专家登记他们的兴趣，然后仲裁员将在这两种情况下以相同的方式工作。

这种相似性并非巧合。黑板架构最初是作为基于规则的系统的一种泛化而提出的：在这种泛化中，规则可以有任何类型的触发器和任何类型的规则。

这样做的一个副作用是，如果你打算在游戏中同时使用黑板系统和基于规则的系统，你可能只需要实现黑板系统。然后，您可以创建简单规则的“专家”：黑板系统将能够管理他们。

当然，黑板语言必须能够支持您打算执行的基于规则的匹配。但是，如果您计划实现我们前面讨论的基于规则的系统中所需的数据格式，那么它将可用于更灵活的黑板应用程序。

如果你的基于规则的系统可能相当稳定，并且你正在使用 Rete 匹配算法，那么对应关系就会崩溃。因为黑板架构是基于规则的系统的超集，所以它不能从特定于规则处理的优化中受益。

#### 有限状态机

不太明显的是，有限状态机也是黑板架构的一个子集（实际上，它们是基于规则的系统的子集，因此也是黑板架构）。黑板被单一状态所取代。专家被转换所取代，根据外部因素决定是否采取行动，并在采取行动时重写黑板上的唯一项目。在本章的状态机中，我没有提到仲裁者。我以为第一个触发的过渡会触发。这只是第一个适用的仲裁算法。

其他仲裁策略在任何状态机中都是可能的。我们可以使用动态优先级、随机算法或任何类型的排序。它们通常不被使用，因为状态机被设计得很简单；如果状态机不支持您正在寻找的行为，则仲裁不太可能成为问题。

状态机、基于规则的系统和黑板架构形成了一个表示能力和复杂性不断提高的层次结构。状态机速度快、易于实现且限制性强，而黑板架构往往显得过于通用而不切实际。正如我们在引言中看到的，一般规则是使用最简单的技术来支持您正在寻找的行为。