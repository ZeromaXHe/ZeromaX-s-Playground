https://www.gameaipro.com/

# 第 II 节 架构

# 8 模块化 AI

*Kevin Dill and Christopher Dragert*

## 8.1 简介

重复在人工智能中无处不在。相同的模式、相同的代码片段、相同的数据块、相同的子决策在一个又一个的决策中被反复使用。一般来说，当我们作为软件工程师看到重复时，我们会尝试将其封装：将其放入过程中，放入类中，或构建一些抽象，以便只有重复模式的一个实例。现在可以重用此封装，而不是为每个新用例重写它。我们在整个软件工程中都看到了这种方法：在过程、类、设计模式、C++ 模板和宏以及数据驱动设计中——仅举几个例子。

减少重复有很多优点。它减小了可执行文件的大小。它减少了引入 bug 的机会，增加了测试代码的方式。它避免了你在一个地方修复错误或进行改进，但在其他地方没有的情况。它在实现过程中节省了时间，允许您编写新代码，而不是重写已经存在的代码。它允许您构建健壮、功能丰富的抽象，这些抽象可以执行复杂的操作，如果您只使用一次，这些操作将需要太多时间来实现。然而，除了所有这些增量优势之外，它还提供了一些基本的东西。它允许您将一段代码的所有细节和面向细节的荣耀打包成一个人类级别的概念，可以在整个项目中重复使用和重新调整用途。它允许您更接近您自然思考的粒度级别，以及您的设计师自然思考的级别，而不是机器自然的级别。例如，它会发生变化：

```c++
d = sqrt(pow((a.x - b.x), 2) + pow((a.y – b.y), 2));
```

变为：

```c++
d = Distance(a, b);
```

然而，人工智能的挑战在于，虽然一个决策的某些方面往往与其他决策相似，但也总是有一些方面截然不同。人工智能可能会测量两个物体之间的距离，以确定是否向某物射击，并确定在哪里吃午饭，但评估的物体以及在更大决策中使用距离的方式肯定会有所不同（除非你正在构建一个喜欢在餐馆射击并吃掉敌人的非玩家角色（NPC））。因此，虽然距离函数本身是大多数数学库的标准部分，但基于距离的决策涉及的代码量要大得多，更难封装和重用。

模块化人工智能从根本上讲就是这种转变。它是关于通过将代表人类概念的模块化组件连接在一起，使您能够快速指定决策逻辑。它是关于建立这些模块化组件的集合，其中每个组件只实现一次，但会在当前游戏的整个 AI 中反复使用，并在下一个游戏和之后的游戏中继续使用。它让你能够把大部分时间花在思考人类大小的概念上，从单个概念（如距离、视线、移动、发射武器）到更大的行为（掩护、选择和攻击目标）再到整个性能（远程武器战斗），然后在其他地方进行适当的定制，重复使用这些部件。这是一种方法，可以让你更快地创建决策逻辑，更容易地更改它，更广泛地重用它，同时工作更可靠，产生的错误更少，因为底层代码的使用更频繁，因此测试更稳健，也因为为一种情况添加的新功能可以立即作为它们改进的可重用组件的一部分在其他地方使用。

本章将首先讨论模块化人工智能的理论基础，并将其与软件工程中广泛接受的概念联系起来，然后详细描述游戏人工智能架构（GAIA）。GAIA 是洛克希德·马丁旋转和任务系统公司开发的一种模块化架构，已被用于在许多非常不同的游戏和模拟引擎中驱动许多非常不同项目的行为，包括（但不限于）教育游戏和训练模拟。它的根源可以追溯到 Blue Fang Games 的动物 AI，Mad Doc Software 的动作游戏 boss AI，以及 Rockstar Games 的环境人类AI。

### 8.1.1 使用本章

本章深入探讨，不同的读者可能对讨论的不同方面感兴趣。如果你的主要兴趣是模块化人工智能背后的大思想以及模块化部件如何协同工作，那么你的重点应该放在第 8.2、8.5 和 8.6 节上。如果您对一种可以立即带走并在现有架构中使用的方法感兴趣，而无需从头开始，那么您应该考虑只实现考虑因素（第 8.5.1 节和第 8.6 节）。最后，如果你对一个可以在许多项目、许多游戏引擎中重用的完整架构感兴趣，并且它允许你以模块化的方式快速配置你的人工智能，那么整个章节都适合你！

## 8.2 理论基础

模块化人工智能和一般的模块化方法旨在提高开发的抽象水平。一个好的模块化解决方案不是关注算法和代码，而是关注人工智能行为及其如何组合在一起，抽象出实现细节。问题是如何安全、正确地完成这项工作，同时仍然为设计师和开发人员提供引发预期行为所需的细粒度控制。

模块化人工智能开发的成功是由良好软件开发中的相同原则驱动的：封装、多态性、松耦合、清晰的操作语义和复杂性管理。这些熟悉的概念中的每一个都在模块化环境中获得了新的含义。

模块本身封装了一个人工智能功能单元。好的模块遵循“金发姑娘规则”：不太大，也不太小，但大小恰到好处。包含多种功能的大型模块会抑制重用——如果新AI只需要部分功能呢？太小的模块不足以提高抽象级别。目标是在设计师用来推理游戏中 NPC 的同一水平上捕捉AI功能。然后，开发问题转向选择和集成新 NPC 所需的行为和功能，而不是从头开始实现这些功能，这是一个非常合适的抽象级别。

以这种方式使用模块需要模块重用是安全的。为此，必须严格执行模块封装。防止模块之间的意大利面条式交互可确保每个模块都能独立正确运行。这对于重用至关重要——即使模块之间微妙的依赖关系也会很快成为问题。

封装自然会导致模块接口的创建。与 API 非常相似，模块接口准确地描述了如何与该模块交互。它显示了它可以接受的输入、提供的输出，并详细说明了在应用于特定 AI 时为定制模块行为而公开的参数。通过显式接口，处理行为之间的依赖关系变得更简单，即连接正确表达行为所需的输入和输出。由于每个模块都被正确封装，因此添加和删除新模块的结果变得可以预测。

多态性是这种松散耦合的结果。想象一下，一个模块的任务是逃离敌人。作为一个一口大小的模块，它可以执行找到合适的逃跑目的地所需的检查和测试，然后发送移动输出。接收此输出的模块不再重要。一个 AI 可以使用某种类型的移动模块，而另一个 AI 则可以使用另一个。移动模块的确切类型应该无关紧要。复杂的因素，如“我的 NPC 在自行车上吗”或“她在马上吗”等，都可以通过移动模块或其他子模块来处理。这使每个模块都清晰地专注于一个功能目的，同时确保类似的行为不会在模块之间重复。

## 8.3 概述

GAIA 是一个模块化、可扩展、可重用的工具集，用于指定程序决策逻辑（即人工智能行为）。GAIA 强调游戏设计者在创建决策逻辑中的作用，同时仍然允许由此产生的行为灵活并对应用程序中的即时情况做出反应。

以更慢的速度看待这些观点，GAIA 是：

- 可用于指定程序决策逻辑（或“AI 行为”）的工具库。
- 专注于提供作者控制。换言之，GAIA 的目标不是创建一个可以自己决定做什么的真正的人工智能，而是为人类作者提供指定决策的工具，这些决策将提供预期的体验，同时仍然保持足够的灵活性来处理各种意外的情况。
- 模块化，这意味着行为通常是通过将预定义的组件插在一起构建的。经验表明，这种方法大大提高了指定和迭代行为的速度。
- 可扩展性，使向库中添加新组件或更改现有组件的行为变得容易。
- 可重复使用，这意味着 GAIA 的设计从一开始就考虑到了重复使用。这包括代码和数据的重用，以及在当前项目、未来项目甚至不同游戏引擎中的重用。

GAIA 是数据驱动的：行为在 XML 文件中指定，然后由代码在运行时加载。本章通常将 XML 称为配置或数据，将 C++ 称为实现或代码。为简单起见，本章还将使用术语 NPC 表示 GAIA 控制的实体，PC 表示玩家控制的实体和字符表示可能是 NPC 或 PC 的实体。

### 8.3.1 GAIA 控制流程

GAIA 通过在决策者（推理者）树上向下工作来做出决策，这在许多方面类似于达米安·伊斯拉（Damian Isla）最初对行为树（BT）的设想（Isla 2005）。与BT一样，不同的推理者可以使用不同的决策方法，这为架构提供了在更同质的分层方法（例如，分层有限状态机、远程或主动编程、分层任务网络规划器等）中不可能实现的灵活性。

每个推理者从其选项中进行选择。选项包含推理器用来决定选择哪个选项的考虑因素，以及在选择选项时执行的操作。动作可以是具体的，这意味着它们代表了受控角色实际应该做的事情（例如，移动、射击、说出一行对话、恐惧中畏缩等），也可以是抽象的，意味着它们包含更多的决策逻辑。

最常见的抽象操作是 `AIAction_Subreasoner`，它包含另一个推理器（具有自己的选项、考虑因素和操作）。GAIA使用子风险人行动来创建其层次结构。当选择包含子原因的选项时，该子原因将开始评估自己的选项并选择一个执行。该选项可能包含具体操作，也可能包含另一个子原因操作。

选项还可以包含多个操作，这允许它们并行运行多个具体操作、子原因或两者的组合。

### 8.3.2 GAIA 实施概念

推理者、选项、考虑因素和行动都是概念抽象的例子。概念抽象是构成模块化人工智能的基本对象类型。每个概念抽象都有一个定义它的接口，以及一组实现该接口的模块化组件（或仅是组件）。如上所述，例如，有多种不同类型的推理器，但所有推理器——即实现推理器概念抽象的所有模块化组件——共享相同的接口。因此，周围的代码不需要知道它有什么类型的组件。例如，推理器不需要知道评估选项时使用了哪些特定类型的考虑因素，也不需要知道这些考虑因素是如何配置的——它只需要知道如何使用考虑因素界面来获得所需的评估。这是模块化人工智能背后的关键思想：识别人工智能的基本部分（概念抽象），为每个抽象声明一个接口，然后定义实现该接口的可重用模块化组件。

模块化组件构成了模块化AI重用的核心——每种类型的组件只实现一次，但会被多次使用。为了实现这一点，每种类型的组件都需要知道如何从配置中加载自己，以便在数据中定义定义模块化组件特定实例功能的所有参数。

继续介绍中的距离示例，GAIA 通过提供距离考虑因素使距离评估可重复使用。特定距离考虑的配置指定了测量两者之间距离的位置，以及如何评估该距离（它应该更近吗？更远吗？它必须在特定范围内吗？）。例如，选择射击目标的狙击手可能会使用距离考虑来评估每个潜在目标。这种考虑可能被配置为只允许狙击手向 50 米以上 500 米以下的目标射击，并优先选择更近的目标。然后，这种考虑可以与其他考虑因素相结合，这些考虑因素可以衡量潜在目标是朋友还是敌人，目标有多少掩护，是否是高价值目标（如军官），等等。更重要的是，这种考虑不是孤立的——它在配置中利用了其他概念抽象。例如，这两个位置是使用目标指定的，距离与其他考虑因素的结合方式是使用权重函数指定的。目标和权重函数是 GAIA 中的另外两个概念抽象。

这种方法的一个优点是它具有高度的可扩展性。随着开发的进展，您发现了应该在决策中权衡的新因素，您可以创建新的考虑因素来评估这些因素，并简单地将其放入其中。因为它们与所有其他考虑因素共享相同的界面，所以其他任何事情都不需要改变。这不仅使 AI 行为的迭代速度更快，还降低了引入错误的可能性（因为所有更改都是针对添加的考虑因素进行的，可以单独测试）。因此，在开发周期的后期进行更积极的更改会更安全，这样一旦游戏玩法敲定，QA 就会对你所构建的内容给出真正的反馈，你就可以在开发后期真正完善人工智能。

这种快速指定并轻松重用通用功能的能力大大减少了指定行为所需的时间，通常在几周内就能收回实施成本。我们在几个项目中使用了模块化人工智能，并取得了巨大的成功，这些项目只有几个月的时间来实现整个人工智能，其中包括一款在不到 4 个月的时间内实现了人工智能的游戏，该游戏后来销售了数百万份。

### 8.3.3 示例角色：狙击手

在本章中，我们将使用一个狙击手角色作为示例，该角色基于但不完全相同于为军事应用而构建的角色。从广义上讲，狙击手应该等到其杀伤区（恰好是一个户外市场）有敌人，然后只要市场上还有敌人可以交战，每隔一两分钟就开枪一次，但前提是（a）它没有受到攻击，（b）它有明确的撤退线。如果它受到攻击，它就会试图撤退，但如果它的撤退线被封锁，它就会开始积极反击，尽可能快地与目标交战（无论他们是否在杀伤区）。该配置的总体结构如图 8.1 所示。

图 8.1
狙击手AI的整体结构。未完全定义的AI方面用虚线显示。

在决策层次的顶层，我们的狙击手只有四种选择：狙击杀伤区内的目标、撤退、交战时反击，或者隐藏并等待其他选择之一可用。这些选项之间的决定是相当简单的，因此一个相当简单的推理器应该可以工作。GAIA 包括一个基于规则的推理器，其工作原理很像 BT 中的选择节点——也就是说，它只是按照指定的顺序评估其选项，并在当前情况下采用第一个有效的选项。在这种情况下，可以按如下方式设置基于规则的推理器：

- 如果狙击手受到攻击，且其撤退路线清晰，则撤退。
- 如果狙击手受到攻击，反击。
- 如果狙击手的撤退线很清楚，那么在杀伤区就有一个有效的目标，而且距离狙击手最后一次狙击已经过去了一两分钟。
- 隐藏。

这些选项都不太可能包含具体行动。例如，撤退将需要人工智能选择一条路线，沿着这条路线移动，监视敌人，对沿途的敌人做出反应等等。反击要求人工智能选择目标、选择战斗位置、瞄准和发射武器、重新装弹等。隐藏要求它退出视线，然后定期向外窥视，就像检查目标是否可用一样。因此，一旦顶级推理器选择了一个选项（如Snipe），该选项的子推理器将评估自己的选项。例如，在图 8.1 中，我们看到 Snipe 选项使用序列推理器逐步完成射击过程，首先进入适当的姿势（例如“俯卧”姿势），然后举起武器，暂停（模拟瞄准），最后射击。

## 8.4 GAIA 基础设施

在深入研究不同的概念抽象和模块化组件之前，了解周围的基础设施是有帮助的。本节概述了主要的单例、数据存储和其他对象，这些对象本身不是模块化的，但支持模块化组件之间的评估和通信。

### 8.4.1 AIString 类

字符串非常有用，但它们也占用了不合理的空间，比较起来很慢。这个问题有很多解决方案；GAIA 使用 djb2 哈希函数(http://www.cse.yorku.ca/~oz/hash.html）为字符串生成 64 位哈希，然后保存一个包含所有原始字符串（作为 std::string）的全局字符串表。这使 GAIA 能够进行恒定时间比较，并以 64 位存储字符串的副本。它还允许 GAIA 在散列字符串时将其小写，这样比较就不区分大小写了（这使得它们对设计人员更加友好）。另一方面，它有一个预先的性能成本，并为每个使用的字符串创建一个永久副本（无论字符串本身是否是临时的），因此 GAIA 仍然在 AIString 没有意义的地方（如调试输出）使用 char* 和 std::string。

值得注意的是，没有哈希函数是保证。如果你采取这种方法，最好有一个断言来检查哈希冲突；每次散列字符串时，只需查看字符串表，并确保存储的字符串与刚刚散列的字符串相同。

### 8.4.2 工厂

GAIA 使用工厂来实例化构成 AI 的所有模块化对象。换句话说，例如，定义考虑因素的配置部分将包含在单个 XML 节点中。GAIA 通过将 XML 节点（以及一些支持信息，如指向此配置将控制的NPC的指针）传递给 AIConsiderationFactory 来创建实际的 C++ 考虑对象，AIConsideration Factory 实例化并初始化适当类型的对象。GAIA 的工厂系统是本书前一章的主题，所以我们不会在这里重复细节（Dill 2016）。

### 8.4.3 AIDataStore 基类

数据存储是AIString索引哈希表，可以存储任何类型的数据。GAIA 将其用作黑板和所有不同类型实体的基础。因此，单个模块化组件可以在黑板和/或实体之间存储、共享和检索信息，而其他 AI 不必知道存储了什么，甚至不知道信息是什么类型。这允许数据被放置在配置中，例如，如果执行了一个动作，游戏引擎将使用该配置，甚至游戏引擎将数据传递给自己。当然，它还允许 AI 组件相互共享数据——我们将在下面的狙击手配置中看到一个例子。

实现这种哈希表的方法有很多，GAIA 并不是特别特殊，所以我们将跳过实现细节。然而，值得一提的是，由于数据存储本质上是全局内存，因此它们存在名称冲突的风险（即两组不同的组件都试图使用相同的名称存储数据）。话虽如此，经验表明，只要你有一个合理的描述性命名约定，这通常不是问题。然而，GAIA 确实有断言来警告存储的数据类型是否不是预期的类型。这不会捕捉到所有可能的名称冲突，但它应该能捕捉到很多冲突。

GAIA 目前有两种黑板和三种实体，如下所述。

#### 8.4.3.1 AIBlackboard_Global 数据存储

游戏有一个单一的全局黑板，可以用作每个人工智能组件都应该可用的信息的中央存储库，无论该组件属于哪个角色或该角色站在哪一边。

#### 8.4.3.2 AIBlackboard_Brain 数据存储

每个由人工智能控制的角色的大脑中都内置了一块黑板。大脑黑板允许组成该角色人工智能的组件相互通信。

#### 8.4.3.3 AIActor 数据存储

每个 NPC 都由一名演员代表。游戏存储了 AI 需要的关于角色的所有信息（例如，角色的位置、方向、可用武器等），AI 组件可以根据需要查找这些信息。演员还包含一个 AIBrain，其中包含该角色的顶级推理器和所有决策逻辑。

在某些项目中，演员被用来代表每个角色，无论是否由人工智能控制。在这些情况下，不受人工智能控制的演员可能没有大脑，或者，如果他们在人工智能和玩家控制之间来回切换，他们将有大脑，但当人工智能无法控制时，大脑将被禁用。

#### 8.4.3.4 AIContact 数据存储

如上所述，有两种方法可以跟踪 NPC 对游戏中其他角色的了解。第一种是使用演员来代表每个角色，并让每个 NPC 大脑中的 AI 组件直接访问其他角色的演员。这是可行的，但这要么意味着所有 NPC 都将拥有完美的信息，要么意味着每个 AI 组件都必须正确检查他们是否应该知道特定的信息。此外，即使人工智能组件进行了这些检查，这仍然意味着他们所知道的一切都是正确的。例如，这使得人工智能更难知道敌人的存在，但对其位置有错误的信念。

另一种方法是让每个 NPC 为它所知道的每个其他角色创建一个联系人，并将其对该 NPC 的知识存储在联系人上。因此，这些联系人代表了 NPC 对游戏中其他角色的了解，无论这些了解是否正确。例如，想象一个角色扮演游戏，玩家偷了一件制服，以便偷偷溜过敌对的警卫。每个守卫都有一个联系人，存储他们对玩家的了解，如果守卫被愚弄，那么该联系人会将玩家列为站在他们一边，即使他或她实际上是敌人。这允许每个 NPC 对它所知道的角色有自己的信念，但这也意味着 AI 必须为每个角色存储大量冗余的信息副本。

这里没有单一的正确答案，这就是为什么 GAIA 支持这两种方法——最好的方法是最能支持单个项目需求的方法。当环境中的不确定性很小（或者角色的行为没有受到太大影响）时，使用演员来代表所有角色更简单、更有效，而当不完美的情境意识在 NPC 的行为中起着重要作用时，使用联系人会更好。

#### 8.4.3.5 AIThreat 数据存储

威胁代表了 NPC 知道并应该考虑做出反应的事情。它们可以包括敌方角色（无论是作为演员还是联系人），但也可能包括更抽象的事情，如最近的爆炸或子弹击中的位置。这使得角色能够对狙击手的射击做出反应，即使他们实际上并不知道枪手，或者根据子弹的撞击位置而不是射击位置来突破掩护。与联系人一样，威胁并不是每个项目都使用的，而是存储在大脑黑板上。

### 8.4.4 单例

Singletons 提供全球可访问的管理器。只需调用该类的静态 `Get()` 函数，就可以从代码库中的任何位置访问单例。您还可以通过调用 `Set()` 将任何单例的默认实现替换为特定于项目的版本（必须是子类）。

#### 8.4.4.1 AIManager 单例

AI 管理员负责存储所有参与者。它还有一个 `Update()` 函数，游戏应该调用每个滴答声，以便滴答作响的演员，从而他们的大脑。

#### 8.4.4.2 AISpecificationManager 和 AIGlobalManager 单例

正如我们所说，GAIA 是数据驱动的。NPC 的所有决策都以 XML 存储在其配置中。规范管理器负责加载、解析和存储所有配置。然后，当游戏创建 NPC 的大脑时，它指定了角色应该使用的配置名称。

数据和代码中都可能出现重复。GAIA 通过允许配置包含全局变量来部分解决这个问题，全局变量是可以在配置中或所有配置中重用的组件规范。全局值由全局管理器存储。Globals 在前面关于工厂的章节中进行了讨论（Dill 2016）。

#### 8.4.4.3 AIOutputManager 单例

良好的调试输出对 AI 开发至关重要。GAIA 通常包含日志消息、警告、错误和断言，以及描述当前决策的“状态文本”（例如，适用于在相关 NPC 旁边的引擎中显示）。输出管理器负责处理所有这些消息，将它们路由到正确的位置，启用/禁用它们等等。

#### 8.4.4.4 AITimeManager 单例

不同的游戏引擎（和不同的游戏）以不同的方式处理游戏时间。时间管理器只有一个函数（`GetTime()`），在整个 AI 中用于实现冷却和最大持续时间等功能。内置实现只是从 CPU 获取系统时间，但大多数项目都实现了自己的时间管理器，提供游戏时间。

#### 8.4.4.5 AIBlackboard_Global 单例

如上所述，全局黑板是一个共享存储空间，可用于在游戏和 AI 之间和/或 AI 组件之间传递信息。它是一个单例，因此可以全局访问，并且项目可以实现自己的版本，如果他们愿意，该版本可以与游戏引擎共享的数据更紧密地耦合。

#### 8.4.4.6 AIRandomManager 单例

随机数是许多游戏的核心，无论是在人工智能内部还是外部。随机管理器包含获取随机值的功能。默认实现使用 Jacopin 在本卷其他地方描述的双 LCG 方法（Jacopin 2016），但与其他单例一样，如果愿意，单个项目可以用使用一些不同 RNG 实现的自定义实现来替换它。例如，我们有一个单元测试项目，它的 RNG 总是返回 0，这使得编写确定性测试变得容易得多。

## 8.5 模块化人工智能：概念抽象和模块化组件

概念抽象定义了架构支持的基类类型。换句话说，这些抽象定义了 GAIA 其余部分将使用的接口。模块化组件是对应的，每个组件都为概念抽象提供了具体的实现。这种方法，其中对象通过定义良好的接口进行交互，允许 GAIA 提供一个支持松耦合模块组合的环境，不受特定实现的限制。开发人员可以自由地考虑产生所需行为的抽象类型，然后通过重用和定制现有的模块化组件或根据需要创建新组件来配置实现。本节将描述 GAIA 使用的主要概念抽象，提供其使用示例，并给出其接口。

### 8.5.1 注意事项

考虑因素是最有用的概念抽象。如果你不确定是否要构建一个完整的模块化人工智能，或者只是在寻找一个可以用来改进现有架构的技巧，那么它们就是开始的地方。

考虑因素用于表示可能被权衡在一起以做出决定的每个不同因素。从本质上讲，每种考虑因素都提供了一种评估行动相对于所考虑因素的适用性的方法。清单 8.1 完整地显示了考虑界面。

Listing 8.1 The consideration interface.

```c++
class AIConsiderationBase
{
public:
    // Load the configuration.
    virtual bool Init(const AICreationData& cd) = 0;
    // Called once per decision cycle, allows the
    // consideration to evaluate the situation and determine
    // what to return.
    virtual void Calculate() = 0;
    // These are GAIA's weight values. They return the
    // results computed by Calculate().
    virtual float GetAddend() const;
    virtual float GetMultiplier() const;
    virtual float GetRank() const;
    // Certain considerations need to know if/when they are
    // selected or deselected.
    virtual void Select() {}
    virtual void Deselect() {}
};
```

为了了解这些在行动中是如何起作用的，让我们来看看狙击手狙击敌人的决定。只有在以下情况下才会选择此选项：

- 撤退路线是明确的。
- 杀伤区有一个目标。
- 狙击手上次开枪已经“一两分钟”了。

构建此选项的配置需要三个考虑因素：上面的每个项目符号都有一个。每一个都是实现考虑接口的模块化组件。

首先，使用 EntityExists 考虑因素来检查狙击手将撤退的区域中是否有任何敌人。EntityExists 考虑因素贯穿所有联系人（或所有参与者，或所有威胁，具体取决于其配置方式），以查看是否至少有一个符合一组约束。在这种情况下，约束条件是该实体必须是敌人，并且必须在狙击手计划逃跑的区域内。该区域是使用区域定义的，这是另一个概念抽象（如下所述）。如果有敌人挡住了撤退线，这第一个考虑因素会否决该选项（即不允许选择），否则它会允许执行该选项（但其他考虑因素仍可能否决它）。

接下来，狙击手需要选择一个联系人进行射击，为此使用了第二个 EntityExists 考虑因素。接触者必须是敌人，并且必须在杀伤区。其他限制可以很容易地添加——例如，狙击手可以被配置为更喜欢距离更近、掩护更少和/或高价值目标（如军官）的接触。该考虑被配置为使用选择器（在稍后的部分中讨论）来选择最佳目标并将其存储在大脑的黑板上。如果选择了该选项，则 Fire 动作将从黑板上检索所选目标，而不是重新选择它。与逃生路线一样，如果没有找到目标，这一考虑将否决该选项，否则无效。

最后，使用 ExecutionHistory 考虑因素来检查狙击手上次开枪已经有多长时间了。这种考虑选择 60 到 120 秒之间的随机延迟，如果自上次射击以来的时间小于该延迟，则否决该选项。每次选择该选项时（即每次推理机选择此选项并开始执行时），考虑因素都会选择一个新的延迟用于下一次射击。

考虑因素是最强大的概念抽象，可以与本章中描述的其他想法一起使用，也可以不使用。它们易于实现（唯一稍微棘手的部分是决定如何将它们组合在一起——本章稍后将详细讨论这个主题），但它们本身可以大大减少重复并提高代码重用率。一旦你有了它们，配置决策就变成了枚举选项并指定每个选项的考虑因素的简单问题。指定一个考虑因素并不比在代码中编写一个函数调用复杂得多——它通常需要几秒钟到一两分钟的时间——但每个考虑因素代表几十行，甚至经常是几百行代码。你需要不时地添加一个新的考虑因素，或者为现有的考虑因素添加新的功能——但你只需要为每个考虑因素做一次，然后你就可以在整个人工智能中一次又一次地使用它。

由于考虑因素被大量重复使用，它们还允许您花时间为决策添加可能难以纳入的细微差别。EntityExists 是一个很好的例子，说明考虑因素会变得多么复杂和强大，但即使是像 ExecutionHistory 这样非常简单的考虑因素，也可以根据选项执行了多长时间、自上次运行以来运行了多长时间，或者它是否曾经运行过来做出决定。这使我们能够实现冷却、目标惯性（又称滞后）、重复处罚和一次性奖金等功能（这些概念在我们之前的工作中进行了详细讨论[Dill 2006]）。它还可以支持广泛的评估函数，这些函数根据经过的时间来驱动决策——例如，通过与随机值进行比较（正如我们在这个例子中所做的那样）或应用响应曲线（如 Lewis 关于效用函数选择的章节和 Mark 关于行为数学的书[Lewis 2016，Mark 2009]中所述）。有一个单一的考虑因素可以完成所有这些，这意味着你可以在几秒钟内重用它，而不是花几分钟甚至几个小时重新实现它。这也意味着当你重用它时，你可以相信它会起作用，因为它已经经过了大量测试，因此不太可能包含错误。

上面没有讨论的一个问题是，推理者实际上是如何结合考虑因素来评估每个选项的。这是一个很大的话题，所以我们现在将绕过它（我们在下面用一整节来讨论它），简单地说，考虑因素会返回一组权重值，这些权重值被组合在一起以指导推理者的决策。

### 8.5.2 权重函数

虽然考虑因素在减少代码库中的重复方面做了很多工作，但不同类型的考虑因素之间仍然有很多重复。因此，创建了许多剩余的概念抽象，以便我们将重复的代码封装在考虑因素本身中。第一个是权重函数。

许多不同类型的考虑因素计算一个浮点值，然后将该单个浮点值转换为一组权重值。权重函数抽象负责进行转换。例如，“距离”考虑因素计算两个位置之间的距离，然后使用权重函数将该浮点值转换为一组权重值。有些游戏可能会使用健康考虑，这对 NPC 的健康（或敌人的健康）也有同样的作用。其他游戏可能会考虑弹药。我们在狙击手身上使用的处决历史考虑是另一个例子。它实际上有三个权重函数：一个在选择选项时使用，一个在从未选择过的情况下使用，另一个在以前选择过但现在没有选择的情况下用。

当然，并非所有因素都会产生浮点值。例如，EntityExists 考虑因素会产生一个布尔值：如果找到实体，则为TRUE，如果没有找到，则为 FALSE。然而，EntityExists 考虑的不同实例可能会为TRUE或FALSE返回不同的权重值。在狙击手的例子中，一个 EntityExists 考虑因素在发现实体时否决了该选项（检查撤退线的实体），而另一个则在没有找到实体时否决该选项（选择射击目标的实体）。这是通过更改每个人使用的权重函数的配置来实现的。其他考虑因素也可能产生布尔值——例如，如果两个角色之间有视线，一些游戏的 LineOfSight 考虑因素可能为TRUE，如果没有视线，则为 FALSE。

我们可以通过多种不同的方式将输入值转换为一组权重值。对于浮点数，我们可以应用响应曲线（BasicCurve 权重函数），或者我们可以将可能的输入值划分为多个部分，并为每个部分返回一组不同的权重值（例如，如果到敌人的距离小于 50 米或大于 300 米，则否决 Snipe 选项，但如果它介于两者之间，则不否决 FloatSequence 权重函数）；或者我们可以简单地将其视为布尔值（布尔权重函数）。我们甚至可以完全忽略输入值，并始终返回一个固定的结果（常量权重函数）——这通常是在考虑 ExecutionHistory 的情况下完成的，以确保特定的选项只被选择一次，或者如果它从未被选择过，它将获得固定的奖励，例如。

考虑不必知道使用了哪种技术，因此我们使用了一种概念抽象，其中转换是使用一致的接口完成的，不同的方法是作为模块化组件实现的（例如，BasicCurve、FloatSequence、Boolean 或 Constant weight 函数）。这个概念抽象的接口如清单 8.2 所示。

Listing 8.2 The weight function interface

```c++
class AIWeightFunctionBase
{
public:
    // Load the configuration.
    virtual bool Init(const AICreationData& cd) = 0;
    // Weight functions can deliver a result based on the
    // input of a bool, int, float, or string. By default
    // int does whatever float does, while the others all
    // throw an assert if not defined in the subclass.
    virtual const AIWeightValues& CalcBool(bool b);
    virtual const AIWeightValues& CalcInt(int i);
    virtual const AIWeightValues& CalcFloat(float f);
    virtual const AIWeightValues& CalcString(AIString s);
    // Some functions need to know when the associated option
    // is selected/deselected (for example, to pick new
    // random values).
    virtual void Select() {}
    virtual void Deselect() {}
};
```

回到狙击手的例子，EntityExists 的两个考虑因素都将使用布尔权重函数。布尔权重函数配置了两组权重值：一组在输入值为 TRUE 时返回，另一组在为 FALSE 时返回。在这两种情况下，一组权重值将被配置为否决该选项（逃逸路线检查的 TRUE 值，目标选择的 FALSE 值），而另一组权重值将被配置成对最终决定没有影响。

ExecutionHistory 的考虑更有趣一些。它有三个权重函数：一个用于在选项执行时使用（评估自选择选项以来的时间量），一个用于从未选择过选项的情况（评估自加载游戏以来的时间），另一个用于过去选择过选项但当前未选择的情况（评估自上次停止执行以来的时间总量）。在这种情况下，当选择该选项时（即当狙击手正在射击时），我们使用配置为无效的恒定权重函数。我们还为从未以相同方式选择选项的情况配置了权重函数——狙击手一旦找到目标，就可以进行第一次射击。第三个权重函数（如果该选项当前未被选择但过去已被执行，则使用该函数）使用 FloatSequence 权重函数来检查输入值是否大于我们的冷却时间，并返回适当的结果。此权重功能还配置为每次选择该选项时随机化冷却。

### 8.5.3 推理机

如前几节所述，推理机实现了负责决策的概念抽象。每个推理机组件的配置将指定推理机的类型，以及推理机的选项。每个选项都可以包含一组考虑因素和一组操作。推理器使用这些考虑因素来评估每个选项并决定选择哪个选项，操作指定了选择相关选项时应该发生什么。清单 8.3 给出了此抽象的接口。

Listing 8.3 The reasoner interface

```c++
class AIReasonerBase
{
public:
    // Load the configuration.
    virtual bool Init(const AICreationData& cd);
    // Used by the picker to add/remove options
    void AddOption(AIOptionBase& option);
    void Clear();
    // Enable/Disable the reasoner. Called when containing
    // action is selected or deselected, or when brain is
    // enabled/disabled.
    void Enable();
    void Disable();
    bool IsEnabled() const;
    // Sense, Think, and Act.
    // NOTE: Subclasses should not overload this. Instead,
    // they should overload Think() (ideally they shouldn't
    // have to do anything to Sense() or Act()).
    void Update();
    // Get the current selected option, if any. Used by the
    // picker.
    AIOptionBase* GetSelectedOption();
    // Most reasoners are considered to be done if they don't
    // have a selected option, either because they failed to
    // pick one or because they have no options.
    virtual bool IsDone();
protected:
    void Sense();
	virtual void Think();
	void Act();
};
```

GAIA 目前提供四种不同的模块化推理机组件：

- 序列推理器，按照配置中列出的顺序执行其选项（很像 BT 中的序列节点）。与其他类型的推理器不同，序列推理器始终执行其每个选项，因此它忽略了可能对其进行的任何考虑。
- 基于规则的推理器，它使用每个选项的考虑因素来确定选项是否有效（即，在当前情况下是否应该执行）。每次勾选，此推理器都会按照配置中指定的顺序向下查看选项列表，并选择第一个有效的选项。这与许多BT实现中的选择器节点的方法基本相同。
- FSM 推理器，它允许我们实现有限状态机。对于这个推理器，每个选项都包含一个转换列表，而不是考虑因素。每个转换都指定了一组考虑因素（决定是否应该进行转换），以及如果转换确实启动，应该选择的选项（即状态）。推理器使用选择器（如下文第8.7节所述）从过渡中进行选择。
- 双效用推理机，是 GAIA 基于效用的推理机。双效用推理器计算两个浮点值：排名和权重。然后，它使用这两个值以及随机数生成器来选择一个选项。我们之前的工作（Dill 2015，Dill 等人 2012）和第 8.6.2 节讨论了双重效用推理。

当然，模块化架构不需要仅限于这些决策方法。例如，我们经常考虑实现一个面向目标的行动计划器（GOAP）推理器（对于那些我们想搜索满足某个目标的行动序列的情况）。与 FSM 推理器一样，这需要一些聪明的思考，但通过实现一种新型的推理器组件，应该很有可能融入 GAIA。

### 8.5.4 行动

动作是推理器的输出——它们负责将命令发送回游戏，对黑板进行更改，或者推理器决定做的任何其他事情。它们的接口如清单 8.4 所示。

Listing 8.4 The action interface

```c++
class AIActionBase
{
public:
    // Load the configuration.
    virtual bool Init(const AICreationData& cd) = 0;
    // Called when the action starts/stops execution.
    virtual void Select() {}
    virtual void Deselect() {}
    // Called every frame while the action is selected.
    virtual void Update() {}
    // Check whether this action is finished executing.
    // Some actions (such as a looping animation) are never done,
    // but others (such as moving to a position) can be completed.
    virtual bool IsDone() { return true; }
};
```

如上所述，行动可以是抽象的，也可以是具体的。抽象行为是指指导决策过程的行为，如子因素行为。其他抽象操作包括 Pause 和 SetVariable 操作。暂停操作在标记为完成之前会延迟指定的时间。它通常用于序列推理机，以控制具体动作的时间。SetVariable 动作用于在数据存储（通常是大脑的黑板）上设置变量。

具体行动就其性质而言，不能作为 GAIA 库的一部分来实施。它们包含用于使 NPC 做事的游戏特定代码。常见的具体操作包括 Move、PlayAnimation、PlaySound、FireWeapon 等。我们的工厂系统处理允许开发人员将游戏特定代码注入 AI 的任务（Dill 2016）。

### 8.5.5 目标

目标为组件配置提供了一种抽象的方式来指定位置和/或实体。例如，“距离”考虑测量两个位置之间的距离。为了使这种考虑可重用，GAIA 需要在配置中指定这两个位置应该是什么。也许一个是 NPC 的位置，另一个是玩家的位置。也许一个是敌人，另一个是 NPC 被指派保护的目标（例如在“夺旗”风格的游戏中）。理想情况下，距离考虑不应该知道它测量的点之间是如何计算的——它应该有一些机制来获得这两个位置，然后可以从那里进行计算。同样，LineOfSight 考虑需要知道在哪些位置或实体之间检查视线，Move 动作需要知道移动到哪里，FireWeapon 动作需要知道射击什么，等等。

GAIA 对此的解决方案是目标概念抽象，其接口如清单 8.5 所示。目标为其他组件提供位置和/或实体以供使用。例如，Self 目标返回AI控制的 NPC 的演员和位置。ByName 目标按名称查找角色（根据配置方式，可以从参与者或联系人中查找）。

Listing 8.5 The target interface

```c++
class AITargetBase
{
public:
    // Load the configuration.
    virtual bool Init(const AICreationData& cd) = 0;
    // Get the target's position. If the target has an
    // entity, it should generally be that entity's
    // position.
    virtual const AIVectorBase* GetPosition() const = 0;
    // Not all types of targets have entities. If this one
	// does, get it. NOTE: It's possible for HasEntity() to
	// return true (i.e. this type of target has an entity)
	// but GetEntity() to return NULL (i.e. the entity that
    // this target represents doesn't currently exist). In
    // that case, HasEntity() should return true, but
    // IsValid() should return false.
    virtual AIEntityInfo* GetEntity() const { return NULL; }
    virtual bool HasEntity() const { return false; }
    // Checks whether the target is valid. For instance, a
    // target that tracks a particular contact by name might
    // become invalid if we don't have contact with that
    // name. Most target types are always valid.
    virtual bool IsValid() const { return true; }
};
```

所有目标都可以提供位置，但有些目标不提供实体。例如，Position 目标返回一个固定的（x，y，z）位置（在目标的配置中指定），但不返回实体。编写配置的人应该意识到这一点，并确保在需要实体的情况下不要使用不提供实体的目标，但 GAIA 也有相应的检查来确保这一点。在实践中，这真的从来不是问题——在需要实体的情况下使用位置目标根本没有意义，那么开发人员为什么要这样做呢？

与所有概念抽象一样，某些类型的目标可以在 GAIA 中实现，而其他类型的目标则需要通过游戏来实现。例如，某些游戏可能会添加一个玩家目标，该目标返回 PC 的联系人（或演员）。对于其他游戏（如多人游戏，或玩家不在世界中的游戏），这种类型的目标是没有意义的。

### 8.5.6 区域

区域类似于目标，除了它们指定了一个更大的区域，而不是指定空间中的单个（x，y，z）位置。它们通常用于触发器和出生区等，尽管它们还有无数其他用途。例如，狙击手配置将使用它们来指定杀伤区（它应该射击的区域）和撤退线（它计划穿过以逃跑的区域）。

区域是一种概念抽象，因为为AI设计师提供各种指定它们的方法是有用的。实现可能包括一个圆形区域（指定为中心位置或目标位置以及半径）、一个平行四边形区域（指定为主位置和两个向量，以给出边的长度和角度）和一个多边形区域（指定为由顶点序列）。同样，一些游戏对简单的 2D 区域非常满意，而另一些游戏则需要在所有三维空间中指定一个区域。清单 8.6 给出了此抽象的接口。

Listing 8.6 The region interface

```c++
class AIRegionBase
{
public:
    // Load the configuration.
    virtual bool Init(const AICreationData& cd) = 0;
    // Test if a specified position is within the region
    virtual bool IsInRegion(const AIVector& pos) const = 0;
    // Set the outVal parameter to a random position within
    // the region
    // NOTE: IT MAY BE POSSIBLE FOR THIS TO FAIL on some
    // types of regions. It returns success.
    virtual bool GetRandomPos(AIVector& outVal) const = 0;
};
```

### 8.5.7 其他概念抽象

概念抽象提供了一种强大的机制，使我们能够封装和重用原本必须复制的代码。上面讨论的抽象是最常用的（也是最有趣的），但 GAIA 还包括其他一些抽象，包括：

- 传感器，它提供了一种将数据传递给人工智能的机制（尽管大多数项目只是直接写入数据存储）。
- 执行过滤器，可以控制推理机和/或传感器的运行频率。
- 实体过滤器，它是选择器的替代方案，用于选择满足一组约束的实体。
- 数据元素，它封装了存储在数据存储中的东西。
- 矢量，抽象出特定游戏或模拟如何表示位置的实现细节（事实证明，并非每个项目都使用（x，y，z））。

此外，随着 GAIA 的不断改进，不时会发现并添加新的概念抽象（向量是最新的例子）。GAIA 包含一个宏和模板化类系统，通过调用单个宏并传递抽象名称，我们可以为每个概念抽象创建大部分基础设施，包括它们的工厂和任何全局配置的存储（Dill 2016）。

## 8.6 综合考虑

考虑因素是模块化组件中最重要的一种。在许多方面，它们是 GAIA 所围绕的关键分解。一般来说，它们是构建决策逻辑的小块。它们代表了两个目标之间的距离、目标剩余的健康量或自上次选择特定选项以来的时间等概念。推理者使用这些考虑因素来评估每个选项并选择他们将执行的选项——但推理者应该如何将他们的考虑因素的输出结合起来？

多年来，我们尝试了许多不同的解决方案来解决这个问题。有些很简单，有些则更复杂。本章将从各个方面介绍一种方法：一种非常简单的布尔方法，用于实验教育游戏中的触发系统（Dill 和 Graham 2016，Dill 等人 2015），以及一种更复杂的基于效用的方法，结合三个值来进行期权评估（Dill 2015，Dill 等 2012）。虽然后一种方法最初可能看起来太难使用，但经验表明，它非常灵活，一旦理解了基本惯例，就可以直接用于简单和复杂的决策。

### 8.6.1 简单的布尔考虑因素

将考虑因素结合起来的最简单方法是将它们视为布尔值。每个选项都有一个单独的考虑因素，它要么返回 TRUE（可以选择该选项），要么返回 FALSE（不能选择）。AND、OR 和 NOT等逻辑运算可以被视为常规考虑因素，除非它们包含一个或多个子考虑因素，并返回其子因素的组合评估。因此，一个选项的单一考虑因素通常是 AND或or，其中包含一系列额外的考虑因素（其中一些本身可能是布尔运算）。

这种方法被用于《火星游戏》中的触发系统，这是一款以火星为背景的实验性教育游戏，教授九年级和十年级数学和编程的主题。清单 8.7 中显示了 Mars Game 触发器的一个示例（在 YAML 中指定）。该特定触发器在关卡开始后等待 15 秒，然后播放一行对话框，提示如何解决游戏中的特定挑战，并在黑板上写下一个值，表示提示已被执行。但是，它只在以下情况下播放提示：

- 提示在上一级别中尚未播放（根据黑板上的值）。
- 玩家尚未开始在他们的漫游车上执行 Blockly 程序。
- 玩家的漫游车面向南方或西方（即 180° 或 270°），因为提示描述了如何处理你开始面向错误方向的情况。

Listing 8.7 Trigger a hint

```yaml
playHint_2_9_tricky:
    triggerCondition:
    - and:
    	- delay: # Wait 15 seconds after the
    		- 15 # start of the level.
    - not:
		- readBlackboard: # Check the blackboard and
			- thisOneIsTrickyHint # only play it once.
		- not: # Don't play it if the player
			- isBlocklyExecuting: # has already started their
				- rover # program.
		- or:
			- hasHeading: # Only play it if the rover
				- rover # is facing south or west.
				- 180
			- hasHeading:
				- rover
				- 270
	actions:
	- playSound: # Play the hint dialog.
		- ALVO37_Rover
	- writeToBlackboard: # Update the blackboard so
		- thisOneIsTrickyHint # that it won't play again.
```

这种方法具有非常简单的明显优势。大多数开发人员，甚至是游戏设计师，都熟悉布尔逻辑，因此它不仅易于实现，而且易于使用。它适用于触发系统和基于规则的推理器，这些推理器可以单独对每个选项做出决策，而不需要将两个选项进行比较来决定哪个是最好的。然而，如果有一种情况，你确实想做出更微妙的决定，那么它会受到很大的影响——这些情况经常出现在项目的后期，当设计师（或 QA、出版商或公司所有者）来找你说“它的功能大多很棒，但在这种情况下，我希望它……”

考虑到这一点，大多数项目最好采用一种方法，该方法允许以简单的方式指定布尔决策，但也支持在需要的时间和地点进行复杂的比较，这让我们考虑到双重效用。

### 8.6.2 双重效用考虑因素

双重效用考虑是 GAIA 使用的方法。每个对价返回三个值：加数、乘数和秩。然后将这三个值组合在一起，以创建选项的总体权重和排名，这两个效用值为这种方法命名。

#### 8.6.2.1 计算权重和排名

一次一个地采取这些步骤，首先发生的是将加数和乘数组合成选项的总权重（WO）。这是通过首先将所有加数相加，然后将结果乘以所有乘数来实现的。

$$W_O = (\sum\limits^n_{i=1}A_i)\cdot(\prod\limits^n_{i=1}M_i)$$			(8.1)

接下来，计算选项的总体排名（$R_O$）。这是通过考虑因素的最大等级来实现的。

$$R_O=Max^n_{i=1}(R_i)$$

还有其他公式可用于计算权重和排名，GAIA 确实支持一些替代方案（稍后将对此进行更多介绍），但绝大多数时候，这两个公式都是我们使用的公式。

#### 8.6.2.2 选择选项

一旦计算出权重和排名，推理机就需要使用它们来选择一个选项。如何做到这一点取决于推理机的类型，但所有推理机都基于双效用推理机。

双重效用推理背后的想法是，人工智能将使用排名将选项划分为类别，然后使用基于权重的随机从排名最高的类别中选择选项。事实上，实现这一目标实际上有四个步骤：

1. 消除任何 $W_O\le 0$ 的选项。在步骤 4 中无法选择它们，这将使步骤 2 更加复杂，因此最好提前消除它们。
2. 从剩下的选项中找出排名最高的选项，并删除排名低于此的任何选项。这一步确保只考虑排名最高的类别中的选项。
3. 从剩下的选项中找出权重最高的选项，并删除权重“远低于”该权重的选项。“远低于”被定义为推理机配置中指定的百分比，在许多情况下，推理机被配置为完全跳过此步骤。这一步可以确保当存在更好的选项时，基于权重的随机选择不会选择权重很低的选项，因为这样做通常看起来很愚蠢——这个选项在技术上是可能的，但考虑到其他可用的选项，它不是很明智。
4. 使用基于权重的随机从剩余选项中进行选择。

有几件事值得一提。首先，注意步骤 1。任何选项都可以通过将其权重设置为0来消除，无论其他选项的权重和排名如何。更重要的是，回顾方程式 8.1，任何考虑因素都可以通过返回0的乘数将选项的权重强制为 0（即否决它），而不管其他考虑因素的值是什么。任何乘以 0 的都是 0。这提供了一种直接的方法来处理双重效用选项，就像它们在我们想要的时候具有纯粹的布尔考虑一样。我们说，如果一个选项的 $W_O>0$，则它是有效的（也就是说它是可选的），否则它是无效的。基于规则的推理器通过按顺序检查其选项，并选择第一个有效的选项来工作，而不管排名如何。

#### 8.6.2.3 配置双公用设施注意事项

实现双重效用考虑的关键是提供默认值，以确保即使系统能够具有相当大的复杂性，在配置考虑时也会隐藏复杂性，除非需要。本节将讨论 GAIA 用于实现此目的的默认值、命名约定和其他技巧。在此过程中，它将给出我们的狙击手 AI 可能用来选择目标的例子。

在 GAIA 中，指定权重值的最基本方法是简单地将加数、乘数和/或秩指定为 XML 中的属性。未指定的三个值中的任何一个都将被设置为无效的默认值（即加数为 0，乘数为 1，秩为 `−FLT_MAX`，这是可能的最小浮点值）。因此，配置 AI 的开发人员只需要指定他或她想要更改的值。

例如，一个好的狙击手应该更喜欢向军官开枪。为了实现这一点，游戏可以在每个联系人上放置一个布尔值“IsOfficer”（记住联系人是数据存储，所以我们可以在那里存储任何我们想要的值）。如果 NPC 认为联系人是军官（无论信念是否正确），则此值为真，否则为假。然后，在配置中，我们使用 BooleanVariable 考虑从 PickerEntity 目标中查找此值（拾取器实体是我们考虑拾取的实体）。如果该值为真，则考虑使用布尔权重函数将乘数设置为 10，否则它什么也不做（即返回默认值）。假设每名军官（体重约为 10）大约有 10 名入伍的敌人（每个敌人的体重约为 1），这意味着，在所有其他条件相同的情况下，狙击手大约有一半的时间会向军官开枪。该考虑因素的配置如清单 8.8 所示。

Listing 8.8 A consideration that prefers to pick officers

```xml
<Consideration Type="BooleanVariable"
               Variable="IsOfficer"
               DataStore="Target">
	<DataStoreTarget Type="PickerEntity"/>
	<WeightFunction Type="Boolean">
		<TrueWeights Multiplier="10"/>
	</WeightFunction>
</Consideration>
```

在某些情况下，无论其他考虑因素如何，考虑因素都希望阻止其选择被选中。例如，当狙击手选择目标时，我们可能希望确保它只向它认为是敌人的实体射击。这可以通过将每个联系人的“侧面”存储为 AIString 来实现，可能的值为“友好”、“敌人”或“平民”。如果“侧面”不是“敌人”，那么狙击手不应该选择这个目标，无论它在哪里，也不管它是不是军官。这可以通过指定乘数 0 来配置，但配置应该更明确，更容易阅读。考虑到这一点，权重可以指定布尔否决属性，而不是指定加数、乘数和秩。如果否决权为真，那么在幕后，乘数将设置为 0。如果为 false，则默认值将用于所有三个权重值。

狙击手的最终考虑因素如清单 8.9 所示。这种考虑与清单8.8中的考虑非常相似，除了它查找字符串变量而不是布尔变量，并将结果传递给 string 权重函数。字符串权重函数试图将字符串与其每个条目进行匹配。如果字符串与任何条目都不匹配，则返回默认值。在这种情况下，这意味着如果字符串是“Enemy”，则考虑因素将无效（因为当否决为 false 时，它将返回默认值），否则它将把乘数设置为 0（因为否决为 TRUE），从而使选项无效。

Listing 8.9 A consideration that vetoes everything other than enemies.

```xml
<Consideration Type="StringVariable"
               Variable="Side"
               DataStore="Target">
	<DataStoreTarget Type="PickerEntity"/>
	<WeightFunction Type="String">
		<Entries>
			<String Value="Enemy" Veto="False"/>
		</Entries>
	<Default Veto="True"/>
	</WeightFunction>
</Consideration>
```

顺便说一句，清单 8.8 和 8.9 中的考虑很好地展示了为什么模块化人工智能如此强大。这些考虑因素评估数据存储中变量的值。它可以是任何数据存储上的任何变量。在这种特殊情况下，数据存储是使用目标（而不是 NPC 的演员或大脑的黑板）指定的，目标也可以是指定实体的任何类型的目标。一旦考虑因素查找了变量的值，它就会将该值传递给权重函数，以转换为权重值。如果没有考虑因素、数据存储和权重函数的想法，我们就必须为每项检查编写一段专门的代码，这些代码仅在狙击手的目标选择中使用，并在使用布尔数据存储变量的任何其他地方复制。此外，该代码将是几十行 C++ 代码，而不是几行 XML。不过，最重要的是，XML 中指定的值在很大程度上是我们向同事或朋友描述逻辑时使用的人类概念。AI 应该评估什么？它正在考虑射击的目标（PickerEntity 目标）。它应该如何评估这一目标？通过检查它是否是敌人，以及它是否是军官。它应该如何处理这次评估？只向敌人射击，大约有一半的时间能挑出敌方军官。

还有一个配置注意事项的细节尚未讨论。为了被选中，每个选项的权重都需要大于 0，但所有考虑因素的默认加数都是 0。如果我们没有至少一个加数大于 0 的对价，那么总权重保证为 0，原因与我们将乘数设置为0时相同——任何乘以 0 的都是 0。此外，我们希望所有选项的默认权重都是合理的，比如 1。

我们通过 Tuning 考虑来解决这个问题，Tuning 考虑只返回指定的加数、乘数和秩，并且默认加数为 1。该选项的配置可以（并且经常）指定调优考虑因素，但如果没有，则会自动添加一个加 1 的默认调优考虑因素。

#### 8.6.2.4 运行时更改组合技术

到目前为止，我们已经说过，期权拥有考虑因素，并负责为推理者将它们结合在一起。这实际上有点不准确。该选项有一个 AIConsiderationSet，其中包含了考虑因素。考虑集负责组合其考虑因素并返回总权重和排名，它还可以返回其考虑因素的组合加数和乘数，而无需将其乘以总权重。其接口如清单 8.10 所示。这种区别很重要，因为这意味着我们可以在考虑集上放置标志，以指定该特定集中的考虑因素应与不同的规则相结合。此外，还有一种特殊类型的考虑因素，其中包含另一个考虑因素集（称为 AIConsideration_ConsiderationSet）。这使得对一个选项的某些考虑因素制定与其他考虑因素不同的规则成为可能。

组合考虑因素最常用的替代方法是对权重应用不同布尔运算的方法。默认情况下，如果任何对价否决了一个选项（即返回乘数 0），则该选项将不会被选中。这本质上是一个连词（即逻辑与）——所有的考虑因素都必须是“真”的（即乘数大于 0），才能使选项为“真”（即有效）。在某些情况下，我们想要一个逻辑 OR，而不是 AND，也就是说，只要至少有一个考虑因素的乘数不为 0，我们就希望该选项有效。这是通过让对价集忽略乘数小于或等于 0 的任何对价来实现的，除非每个对价都有一个小于或等于零的乘数。同样，NOT 是通过将小于或等于0的任何乘数替换为 1，将大于 0 的任何乘法器替换为 0 来实现的。

Listing 8.10 The AIConsiderationSet interface

```c++
class AIConsiderationSet
{
public:
    bool Init(const AICreationData& cd);
    // Evaluate all of the considerations and calculate the
    // overall addend, multiplier, weight, and rank.
    void Calculate();
    // Sets the best rank and weight currently under
    // consideration. These don't change the calculated
    // values, but they will change the values returned by
    // GetRank() and GetWeight().
    void SetScreeningWeight(float bestWeight);
    void SetScreeningRank(float bestRank);
    // Get the rank and weight. GetWeight() returns 0 if
    // the screening rank or screening weight checks fail.
    float GetWeight() const;
    float GetRank() const;
    // Get the raw values, unscreened.
    float GetAddend() const;
    float GetMultiplier() const;
    float GetWeightUnscreened() const;
    float GetRankUnscreened() const;
};
```

GAIA 还支持组合排名的不同方法：它可以取最小值，也可以将所有考虑因素的排名加在一起，以获得整体排名，而不是取最大值。所有这些更改的配置与其他所有更改一样，也就是说，有一个属性告诉考虑集要使用哪种计算方法，默认情况下（当未指定属性时）使用标准方法。

在Dill（2006）、Dill 等人（2012）、Lewis（2016）和Mark（2009）中可以找到更多配置双公用事业考虑因素和使用公用事业的技术。

## 8.7 挑选器（Picker）

本章我们将讨论的最后一个主题是挑选器。挑选者使用推理器来浏览一系列事情（通常是联系人、参与者或威胁的列表，但也可能是 FSM 选项上的转换列表），并出于某种目的选择最佳的一个（例如，最好的谈话对象、最好的射击对象、最好的掩护对象等）。EntityExists 考虑所使用的选择器（选择实体）和 FSM 推理器所使用的拾取器（选择转换）之间存在细微差异，但核心思想是相同的；为了简洁起见，我们将重点介绍选择实体。

虽然大多数推理器在其配置中定义了所有选项，但选择器的推理器必须从运行时确定的选项中进行选择。例如，我们可能会使用选择器来查看我们的联系人，以选择要射击的东西，或者查看我们的威胁，以选择一个要做出反应的威胁，或者查看附近的掩护位置以选择要使用的掩护位置（尽管游戏必须扩展 GAIA 以支持掩护位置来完成最后一个）。狙击手示例中的 EntityExists 考虑因素使用拾取器来拾取要射击的物体，并检查是否有实体阻挡了其撤退线。第一个选择器应该使用双效用推理器，因为它想选择最佳实体。第二种可能使用基于规则的推理器，因为它只需要知道这样一个实体是否存在。

选择器选项是通过获取某个类别中的所有实体（例如所有参与者、所有联系人或所有威胁），并为每个实体创建一个选项来动态创建的。这些选项中的每一个都有相同的考虑因素，这些因素在配置中指定。考虑因素可以使用 PickerEntity 目标访问他们负责评估的实体。例如，用于选择狙击手目标的选择器可能会考虑检查与目标的距离、目标是否在杀伤区、有多少掩护、是否是敌人、是否是军官等。检查撤退线的拾取器只需检查每个实体是否是敌人，以及它是否在定义逃跑路线的区域内。

将所有内容放在一起，考虑射击的狙击手的一个简单选项可能如清单 8.11 所示。此选项使用 EntityExists 考虑因素来选择目标，然后将所选目标存储在大脑黑板上的 SnipeTarget 变量中。选择者有两个考虑因素——一个是检查目标是否是敌人，另一个是查看它是否在 50 米到 300 米之间。如果找不到目标，它使用布尔权重函数来否决该选项。如果发现目标，它会使用射击动作进行射击。实际上，我们可能希望为选择器添加更多考虑因素（使目标选择更加智能），但关键思想如下。

Listing 8.11 An option for the sniper, which picks a target and shoots at it.

```xml
<Option Type="ConsiderationAndAction">
	<Considerations>
		<!-- Look through the contacts, pick a target, store it
		on the brain's blackboard as SnipeTarget. -->
		<Consideration Type="EntityExists"
                       Location="Contacts"
                       Variable="SnipeTarget">
			<Picker>
                <!-- This picker uses a dual utility reasoner because
                it wants to pick the *best* target. A picker
                that just wants to check whether any entity
                meets some set of constraints (like the one for
                checking line of retreat) would likely use a
                rule-based reasoner instead. -->
                <Reasoner Type="DualUtility"/>
                <!-- Only targets between 50m and 300m away -->
                <Consideration Type="Distance">
                	<FromTarget Type="Self"/>
                    <ToTarget Type="PickerEntity"/>
					<WeightFunction Type="FloatSequence">
                        <Entries>
                            <Entry Exact="50" Veto="true"/>
                            <Entry Exact="300" Veto="false"/>
                        </Entries>
                        <Default Veto="true"/>
                    </WeightFunction>
				</Consideration>
                <!-- Only enemies -->
                <Consideration Type="StringVariable"
                               Variable="Side"
                               DataStore="Target">
                	<DataStoreTarget Type="PickerEntity"/>
                    <WeightFunction Type="String">
                        <Entries>
                            <String Value="Enemy" Veto="False"/>
                        </Entries>
                        <Default Veto="True"/>
                    </WeightFunction>
                </Consideration>
                <!-- Other considerations (like the one to prefer
                officers, or one to check that the target is
                in the kill zone) could be added here. -->
                </Considerations>
            </Picker>
            <!-- Use a default Boolean weight function – that is,
            veto if a target is not found -->
            <WeightFunction Type="Boolean"/>
        </Consideration>
    <!-- The considerations to check line of retreat and time
	since the last shot would go here. -->
    …
    </Considerations>
    <Actions>
        <!-- Fire at the target the picker picked -->
        <Action Type="Fire">
            <Target Type="DataElement_EntityList"
                    Variable="SnipeTarget"/>
        </Action>
    </Actions>
</Option>
```

## 8.8 结论

模块化人工智能是一种人工智能规范的方法，它大量借鉴了软件工程的原则，以大大减少代码重复并提高重用率。它允许开发人员通过将代表人类概念的模块化组件连接在一起，而不是用 C++ 实现代码，来快速指定决策逻辑。因为这些组件只实现一次，然后被广泛重用，所以它们变得比每个组件只使用一次更健壮（即经过更严格的测试）和更丰富的功能（即能够产生更微妙的细微差别）。更重要的是，由于大部分工作都是调用已经编写的代码，因此 AI 规范可以比其他方式更快地完成。模块化人工智能在几个只有几个月的项目中得到了成功的应用，其中包括一款销量超过 500 万份的游戏，我们在不到 4 个月的时间里从头开始（包括实现架构）实现了所有 boss 人工智能。

本章介绍了一个全模块化架构（GAIA），它使用了各种不同类型的模块化组件。在所有这些概念抽象中，考虑因素是迄今为止最强大的。对于那些受限于在现有架构内工作的人来说，即使在现有架构中，也很有可能获得模块化人工智能的大部分好处，只需实现考虑因素并允许它们驱动您的评估功能。我们在另一款畅销游戏中采用了这种方法，并取得了巨大的成功。



# 第 V 节 角色行为

# 34 在 60 FPS 下的 1000 NPC

*Robert Zubek*

## 34.1 简介

在本章中，我们将介绍用于实现 SomaSim 游戏《Project Highrise》中角色的人工智能，这是一款摩天大楼建设管理模拟游戏，玩家可以在其中建造、出租和管理一系列高层建筑。

这款模拟游戏中的 AI 目标是实现一个“生活建筑”，模拟玩家摩天大楼中数百名居民的日常生活、日常生活和日常活动。正如下一节中更详细描述的那样，我们给自己设定了一个基准目标：为了满足游戏需求，多达 1000 名 NPC 应该能够同时居住在玩家的建筑中，而不会在商品硬件上降至 60 FPS 以下。

本章将描述我们如何实现这一目标的人工智能实现。我们将首先看看游戏本身，以说明人工智能问题背后的动机和约束，然后在下一节中，我们将描述我们实现的两个动作选择机制（以及为什么我们决定只使用其中一个），然后是一个实际执行这些动作的高性能系统。

### 34.1.1 关于游戏

让我们快速介绍一下游戏本身，如图 34.1 所示。玩家在 Project Highrise 中的工作是投资高层建筑的建设，然后成功地管理它们：让租户搬进来，让他们满意，确保每个人都得到他们需要的东西，并按时支付租金。与这类管理模拟游戏一样，游戏板上的单元种类和数量不断增加，例如在大楼里租用空间的办公室和餐馆，以及进出这些单元、上班、吃午饭、晚上回家等的角色。

图 34.1
Project Highrise 早期游戏的截图。

我们不会进一步详细介绍游戏中的游戏玩法或经济模拟，因为它们超出了本章的范围，除了指出它们都引入了一个共同的目标：我们需要建筑给人一种活力，充满电脑角色，他们的日常来来往往会让建筑充满不可抗拒的喧嚣。除了美感之外，NPC 的经济活动还推动了建筑的经济性，这为玩家提供了主要的挑战，因此我们需要持续模拟NPC，而不是简单地将其实例化并筛选出来。

我们给自己设定了一个具体的性能目标：游戏需要能够模拟和显示 1000 个 NPC，在相当新的台式个人电脑上以 60 FPS 的速度运行。此外，还有一个资源挑战：我们是一个小团队，我们知道在大部分开发过程中，我们只有一名开发人员，他们的工作不仅涉及人工智能，还涉及构建整个游戏的其余部分。因此，我们需要一个构建速度非常快的人工智能系统，一旦构建完成，只需要很少的持续维护，主要是帮助我们实现性能目标。

早期，我们决定保持简单，将我们的角色 AI 分为两部分，动作选择驱动决策，单独的动作执行模块根据这些命令执行。

## 34.2 动作选择

动作选择是角色 AI 的一个基本决策过程：在给定的时间点我应该做什么？在游戏开发过程中，我们实际上尝试了两种不同的动作选择实现：第一种是命题规划器，第二种是更简单的基于时间的日常例程脚本调度器。

目标是再现日常人类行为：上班族早上上班，也许午休，大部分时间都在办公桌前工作，直到该回家的时候；公寓居民晚上回家，闲逛到睡觉时间；维护和清洁人员在做夜间工作，而其他人都睡着了，等等。

我们不必太担心动画保真度，因为角色只是 2D 精灵。相反，我们的重点是整体角色行为，因为你的居民和工作人员的行为直接推动了游戏经济。例如，你的美食广场餐厅需要那些上班族午休，这样他们才能盈利，而你反过来又依赖这些餐厅支付租金，这样你就可以收回投资。性格行为是经济核心循环的核心。

### 34.2.1 第一系统：命题规划师

规划系统是我们为 NPC 选择行动的第一次尝试。这发生在预制作的早期，当时我们还不知道我们需要或想要从角色身上获得多少“智慧”，但我们知道灵活性至关重要。由于游戏模拟了具有相当简单目标的人，因此使用计划器尝试将一系列动作串在一起以实现这些目标是有意义的。

我们对计划器的运行时性能与性能目标存在一些担忧，因此我们决定使用命题计划器来实现它，因为它具有非常高效的实现潜力。对这样一个规划者的详细描述超出了本章的范围，但我们可以从更高的层次对其进行简要描述。我们所说的命题规划器，是指其前置和后置条件来自一组有限的扎根命题，而不是表示为谓词的规划器。例如，命题规划器中的规划规则可能看起来像这样（用“~”表示否定）：

```
Rule: Preconditions: at-home & is-hungry
    Action: go-to-restaurant
    Postconditions: ~at-home & at-restaurant
```

将此与使用谓词逻辑的规则进行比较，谓词逻辑在 STRIPS 的规划者中更为常见（Fikes 和 Nilsson 1971）：

```
Rule: Preconditions: (at-location X) &
        (desired-location Y) & ~(equal X Y)
    Action: (go-to Y)
    Postconditions: (at-location Y) & ~(at-location X)
```

谓词规则比命题规则更紧凑——它们让我们描述整个实体家族之间的关系。*与此同时，这种表达力是昂贵的：规划者不仅要找到实现目标的正确动作序列，还要为所有这些自由变量找到正确的值绑定集。

然而，命题规则允许一些有趣的优化。由于所有命题在编译时都是已知的，前置和后置条件可以表示为简单的位向量——那么在规划过程中，检查前置条件和应用后置条件的过程可以简化为非常快速的位操作。另一个好处是易于计划缓存：很容易用位掩码注释每个命题计划，该位掩码描述了可以重用该计划的世界状态，以便将来可以逐字缓存和重新应用。同时，命题规则也有一个明显的缺点：它们缺乏谓词逻辑的表达能力，需要更多的命题和规则，这使得何时使用它们变得复杂。

一旦实施，规划者的表现超出了预期。尽管这还处于早期制作阶段，我们还没有定义一套完整的 NPC，但我们直观地知道搜索空间扇出不会是一个大问题。*即便如此，计划缓存还是很有用的：由于相对较少的 NPC 类型过着相当刻板的生活，实际上只有少数不同的计划被创建并缓存，因此计划器在游戏过程中只需要运行那么多次。

正如接下来讨论的那样，我们最终因与绩效无关的原因而放弃了计划。但即便如此，我们的收获是：（1）我们在将规划作为原型AI行为和探索设计空间的一种方式方面有着积极的经验；（2）有很好的方法可以使其在游戏中具有足够的性能（例如，使用命题规划或紧凑的 GOAP 规划器，如[Jacopin 2015]中提出的）。

### 34.2.2 第二系统：每日脚本

在实施角色 AI 的过程中，我们对自己设计的理解发生了变化。我们意识到，我们希望我们的 NPC 过着非常刻板、常规化的生活——他们应该是相当可预测的，因为大楼里有太多的 NPC，玩家无法详细关心他们。我们还希望设计师能对人们的日常生活进行大量控制，以增强游戏的虚构性：这样工人和居民的行为才能与他们工作场所或公寓的社会经济地位相匹配，但同时，在“味道”方面也有很多变化和怪癖

最后，我们意识到，通过采用计划，我们在错误的抽象层次上工作。我们正在创作个人的计划步骤，并试图找出如何在运行时将其转化为正确的行为——但我们真正想做的是，在高层次上创作人们的整个日常生活，这样我们就可以对事情发生的时间和变化方式有很强的作者控制力。我们需要创作的内容不是“我将如何应对这种情况”，而是“我的工作日今天、明天和后天是什么样子的”

用例程表示行为在人工智能中无疑有着丰富的历史。一些以人类学为导向的研究（例如，Schank 和 Abelson 1977，Suchman 1987）提出了一个令人信服的案例，即我们日常的人际交往确实是高度常规化的：在标准情况下，人们学习（或弄清楚）什么时候做什么，而不必从第一原则中重新驱动它，这些刻板的例程驱动着他们的行为。

一旦我们意识到我们在错误的抽象层次上建模行为，解决方案就很明显了：我们决定完全放弃计划，将 NPC 行为重新实现为刻板脚本库，这些脚本是对日常活动的描述，如去办公室、坐下来吃饭、处理租户的维修请求等。然后，脚本将被捆绑在各种日常计划中，根据当前条件，如一天中的时间和简单“工作记忆”的内容（例如，NPC 想去哪里、当前工作在哪里、当前家在哪里等的信息），用非常简单的逻辑选择正确的脚本。下面是一个日常脚本的示例定义，适用于在办公室长时间工作的人：

```
name "schedule-office.7"
blocks [
    { from 8 to 20 tasks [ go-work-at-workstation ] }
    { from 20 to 8 tasks [ go-stay-offsite ] }
]
oneshots [
    { at 8 prob 1 tasks [ go-get-coffee ] }
    { at 12 prob 1 tasks [ go-get-lunch ] }
    { at 15 prob 0.5 tasks [ go-get-coffee ] }
    { at 17.5 prob 0.25 tasks [ go-visit-retail ] }
    { at 20 prob 0.5 tasks [ go-get-dinner ] }
    { at 20 prob 0.25 tasks [ go-get-drink ] }
]
```

该定义分为两部分。在街区部分，我们看到他们从早上 8 点到晚上 8 点在指定的工作站（例如他们的办公桌）工作，否则就呆在家里。那些连续的脚本，如在工作站上工作，是作为简单的循环活动执行的，重复但有可调的变化。然后，oneshots 部分指定了可能发生或可能不发生的单个单镜头脚本，具体取决于概率修饰符 prob，每个脚本本身都有额外的逻辑来决定该做什么（例如，去喝咖啡可能会启动，导致 NPC 去买一杯咖啡，从而在你的大楼里花钱，但如果大楼里没有咖啡馆，它将中止并导致 NPC 抱怨）。最后，如下一节所述，所有这些脚本都按照单个操作的顺序自下而上。

与我们之前的计划方法相比，这种知识表示很简单，但这是一种积极的权衡。有趣的是，在预生产的早期，我们还尝试了一种更复杂的NPC内部人格模型，其中包括饥饿或疲劳等生理状态，但随着时间的推移，我们删除了所有这些细节。原因有两个：（1）内部状态充当了“隐藏信息”，使设计者和玩家都难以理解为什么一个人会以某种方式行事；（2）当乘以数十或数百个 NPC 时，这导致了许多令人沮丧的时刻，试图理解整个群体何时会出乎意料地行事。

我们的主要结论是，详细 NPC 代表的效用与玩家必须管理的 NPC 数量成反比。当模拟的人数很少时，玩家会欣赏他们的复杂性。然而，随着数字的增加，这并没有扩大。必须详细理解和管理它们对玩家和设计师来说都是一种负担，因此随着 NPC 数量的增加，最好提高抽象级别，并限制玩家必须处理的复杂性。

## 34.3 行动表现

我们的两个动作选择系统——计划器和脚本调度器——都产生了NPC需要执行的动作序列。在本节中，我们将看看硬币的另一面：动作表演。我们还将讨论实现高效实现的两个简化：开环动作性能和特定于域的寻路表示。

### 34.3.1 动作队列和开环动作性能

许多 NPC AI 系统都是闭环反馈系统——它们在执行操作时监控世界，并适当调整行为，主要是为了智能地处理故障。然而，这是有代价的：检查世界具有非零的计算成本（基于更新频率、感官模型的保真度等），决定是否对这些新信息采取行动也是如此。一些架构，如包容（Brooks 1986）或远程主动树（Nilsson 1994），接受不断的重新计算和重新计算作为做生意的成本，而各种行为树实现，例如，在各个节点是以远程主动方式重新验证自己还是长时间缓存其激活方面存在很大差异。

在我们的系统中，我们将这一点推向了一个极端：我们几乎完全开环地运行动作性能，而不试图根据世界的变化来监控和修复我们的行为。主要的 AI 设置看起来像这样：

1. 动作选择选择选择一个脚本（例如，去上班），并将其与NPC的工作记忆（例如，我在 243 号办公室工作）相结合，产生一系列简单的动作：进入大厅，等待电梯，乘坐电梯，走进 243 号办公室，坐在我的办公桌前等。
2. 动作被放入动作队列并按线性顺序执行。这在（Zubek 2010）中有详细介绍，但任何玩过《模拟人生》或经典基地建设实时战略游戏的人都会立即熟悉它在运行时的工作原理。
3. 每个操作都可以选择性地监视自定义故障条件。例如，如果找不到到达目的地的路径，导航操作将失败。
4. 如果检测到故障，队列将立即刷新，并且可以选择将回退脚本排队（例如，转向相机，播放不满意的动画，并抱怨这栋楼的条件）。
5. 一旦队列为空，系统会再次运行动作选择，它会选择下一组动作并重新填充队列。

实际上，系统只在无事可做时评估世界，一旦确定了行动方案，它就会开环运行，直到成功或中断。这些动作序列最终也相当短——例如，一个去餐馆吃饭的脚本可能会产生十几个单独的动作，总共需要大约一个小时的游戏时间（或：不到一分钟的实时时间）来执行。

这要归功于这个游戏世界的良性本质：通常可以在不太关注世界的情况下开环运行。如果确实发生了意外，行动选择非常便宜，我们可以放弃之前的活动重新开始。因此，简而言之，对于允许它的游戏设计来说，廉价的动作选择可以实现一系列其他简化，例如跳过适当的故障处理，转而重新开始。

### 34.3.2 简化模型的寻路

第二个优化与寻路有关。游戏发生在一个基本上是二维网格的地方——一个建筑物的剖面侧视图，根据场景的不同，它可以是 100 多层楼高，几百个网格单元宽。当数百名 NPC 试图同时在网格中导航时，在原始网格表示上天真地实现 A* 寻路很快就被证明是不够的。

当然，我们将寻路重新表述为分层的，以减少搜索空间。然而，我们没有使用通用的聚类方法，例如 HPA*（Botea 等人，2004），而是使用我们的领域知识来生成一个专门的紧凑表示，这使得玩家更容易对路径图进行持续的更改（当他们构建、更改或扩展其高层建筑时）。简而言之：根据游戏的设计，可路径空间被划分为不同的地板，这些地板是同一地板上连续的瓷砖序列，这样角色就可以在地板内做直线运动。此外，每个地板都通过楼梯、自动扶梯或电梯与上面或下面的地板相连，统称为连接器。楼板和连接件分别成为我们高级图中的节点和边，每个楼板内的运动变成了简单的直线方法。

这种搜索空间的减少是显著的：以一栋 100 层高、150 瓦宽、有四个电梯井的密集建筑为例，我们将空间从15000个网格单元减少到只有 100 个图形节点，它们之间有 400 条边。此时，数据模型足够小，可以继续运行A*，对启发式函数的额外调整可以防止开集不必要地散开。

我还应该补充一点，我们考虑了原始网格上的 JPS 和 JPS+ 等替代方案，但发现它们不太合适，因为玩家会一直改变网格空间。特别是，JPS（Harabor 和 Grastien 2012）根据需要有效地构建了一个紧凑的表示，以简化其搜索，但随着玩家不断更换游戏板，它将不得不一次又一次地重复它——这似乎不如一开始就保持源数据模型紧凑那么理想。此外，JPS+（Rabin 2015）通过预处理搜索空间获得了性能优势，但这是一个昂贵的步骤，不打算在游戏运行时重复应用。

最后，尽管我们考虑了比 A* 更复杂的方法，但一旦我们意识到如何优化搜索空间而不是优化算法，它们就变得没有必要了。我们利用我们的领域知识大幅简化了数据模型，以至于算法的选择不再重要，这是一个非常积极的发展。人工智能的许多领域都涉及搜索，模型简化是一种使其更易于处理的经典技术。

## 34.4 结论

角色 AI 的大幅简化使我们能够以 60 FPS 的速度实现 1000 个 NPC 的目标，同时降低开发成本。这是一个很好的例子，说明了超级专业化人工智能实现的强大功能，尽管它不能推广到更复杂的行为或更恶劣的环境中，但它非常适合手头的问题，并且没有超出最低要求的额外计算（或创作）负担。

这可能是一个有趣的例子，说明根据手头的问题定制人工智能实现的好处，而不是依赖更通用的中间件。尽管通用解决方案有其地位，但通过无情地削减复杂性，直到没有什么可削减的，可以取得惊人的成就。