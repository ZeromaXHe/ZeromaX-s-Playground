https://www.gameaipro.com/

# 第 V 节 角色行为

# 34 在 60 FPS 下的 1000 NPC

*Robert Zubek*

## 34.1 简介

在本章中，我们将介绍用于实现 SomaSim 游戏《Project Highrise》中角色的人工智能，这是一款摩天大楼建设管理模拟游戏，玩家可以在其中建造、出租和管理一系列高层建筑。

这款模拟游戏中的 AI 目标是实现一个“生活建筑”，模拟玩家摩天大楼中数百名居民的日常生活、日常生活和日常活动。正如下一节中更详细描述的那样，我们给自己设定了一个基准目标：为了满足游戏需求，多达 1000 名 NPC 应该能够同时居住在玩家的建筑中，而不会在商品硬件上降至 60 FPS 以下。

本章将描述我们如何实现这一目标的人工智能实现。我们将首先看看游戏本身，以说明人工智能问题背后的动机和约束，然后在下一节中，我们将描述我们实现的两个动作选择机制（以及为什么我们决定只使用其中一个），然后是一个实际执行这些动作的高性能系统。

### 34.1.1 关于游戏

让我们快速介绍一下游戏本身，如图 34.1 所示。玩家在 Project Highrise 中的工作是投资高层建筑的建设，然后成功地管理它们：让租户搬进来，让他们满意，确保每个人都得到他们需要的东西，并按时支付租金。与这类管理模拟游戏一样，游戏板上的单元种类和数量不断增加，例如在大楼里租用空间的办公室和餐馆，以及进出这些单元、上班、吃午饭、晚上回家等的角色。

图 34.1
Project Highrise 早期游戏的截图。

我们不会进一步详细介绍游戏中的游戏玩法或经济模拟，因为它们超出了本章的范围，除了指出它们都引入了一个共同的目标：我们需要建筑给人一种活力，充满电脑角色，他们的日常来来往往会让建筑充满不可抗拒的喧嚣。除了美感之外，NPC 的经济活动还推动了建筑的经济性，这为玩家提供了主要的挑战，因此我们需要持续模拟NPC，而不是简单地将其实例化并筛选出来。

我们给自己设定了一个具体的性能目标：游戏需要能够模拟和显示 1000 个 NPC，在相当新的台式个人电脑上以 60 FPS 的速度运行。此外，还有一个资源挑战：我们是一个小团队，我们知道在大部分开发过程中，我们只有一名开发人员，他们的工作不仅涉及人工智能，还涉及构建整个游戏的其余部分。因此，我们需要一个构建速度非常快的人工智能系统，一旦构建完成，只需要很少的持续维护，主要是帮助我们实现性能目标。

早期，我们决定保持简单，将我们的角色 AI 分为两部分，动作选择驱动决策，单独的动作执行模块根据这些命令执行。

## 34.2 动作选择

动作选择是角色 AI 的一个基本决策过程：在给定的时间点我应该做什么？在游戏开发过程中，我们实际上尝试了两种不同的动作选择实现：第一种是命题规划器，第二种是更简单的基于时间的日常例程脚本调度器。

目标是再现日常人类行为：上班族早上上班，也许午休，大部分时间都在办公桌前工作，直到该回家的时候；公寓居民晚上回家，闲逛到睡觉时间；维护和清洁人员在做夜间工作，而其他人都睡着了，等等。

我们不必太担心动画保真度，因为角色只是 2D 精灵。相反，我们的重点是整体角色行为，因为你的居民和工作人员的行为直接推动了游戏经济。例如，你的美食广场餐厅需要那些上班族午休，这样他们才能盈利，而你反过来又依赖这些餐厅支付租金，这样你就可以收回投资。性格行为是经济核心循环的核心。

### 34.2.1 第一系统：命题规划师

规划系统是我们为 NPC 选择行动的第一次尝试。这发生在预制作的早期，当时我们还不知道我们需要或想要从角色身上获得多少“智慧”，但我们知道灵活性至关重要。由于游戏模拟了具有相当简单目标的人，因此使用计划器尝试将一系列动作串在一起以实现这些目标是有意义的。

我们对计划器的运行时性能与性能目标存在一些担忧，因此我们决定使用命题计划器来实现它，因为它具有非常高效的实现潜力。对这样一个规划者的详细描述超出了本章的范围，但我们可以从更高的层次对其进行简要描述。我们所说的命题规划器，是指其前置和后置条件来自一组有限的扎根命题，而不是表示为谓词的规划器。例如，命题规划器中的规划规则可能看起来像这样（用“~”表示否定）：

```
Rule: Preconditions: at-home & is-hungry
    Action: go-to-restaurant
    Postconditions: ~at-home & at-restaurant
```

将此与使用谓词逻辑的规则进行比较，谓词逻辑在 STRIPS 的规划者中更为常见（Fikes 和 Nilsson 1971）：

```
Rule: Preconditions: (at-location X) &
        (desired-location Y) & ~(equal X Y)
    Action: (go-to Y)
    Postconditions: (at-location Y) & ~(at-location X)
```

谓词规则比命题规则更紧凑——它们让我们描述整个实体家族之间的关系。*与此同时，这种表达力是昂贵的：规划者不仅要找到实现目标的正确动作序列，还要为所有这些自由变量找到正确的值绑定集。

然而，命题规则允许一些有趣的优化。由于所有命题在编译时都是已知的，前置和后置条件可以表示为简单的位向量——那么在规划过程中，检查前置条件和应用后置条件的过程可以简化为非常快速的位操作。另一个好处是易于计划缓存：很容易用位掩码注释每个命题计划，该位掩码描述了可以重用该计划的世界状态，以便将来可以逐字缓存和重新应用。同时，命题规则也有一个明显的缺点：它们缺乏谓词逻辑的表达能力，需要更多的命题和规则，这使得何时使用它们变得复杂。

一旦实施，规划者的表现超出了预期。尽管这还处于早期制作阶段，我们还没有定义一套完整的 NPC，但我们直观地知道搜索空间扇出不会是一个大问题。*即便如此，计划缓存还是很有用的：由于相对较少的 NPC 类型过着相当刻板的生活，实际上只有少数不同的计划被创建并缓存，因此计划器在游戏过程中只需要运行那么多次。

正如接下来讨论的那样，我们最终因与绩效无关的原因而放弃了计划。但即便如此，我们的收获是：（1）我们在将规划作为原型AI行为和探索设计空间的一种方式方面有着积极的经验；（2）有很好的方法可以使其在游戏中具有足够的性能（例如，使用命题规划或紧凑的 GOAP 规划器，如[Jacopin 2015]中提出的）。

### 34.2.2 第二系统：每日脚本

在实施角色 AI 的过程中，我们对自己设计的理解发生了变化。我们意识到，我们希望我们的 NPC 过着非常刻板、常规化的生活——他们应该是相当可预测的，因为大楼里有太多的 NPC，玩家无法详细关心他们。我们还希望设计师能对人们的日常生活进行大量控制，以增强游戏的虚构性：这样工人和居民的行为才能与他们工作场所或公寓的社会经济地位相匹配，但同时，在“味道”方面也有很多变化和怪癖

最后，我们意识到，通过采用计划，我们在错误的抽象层次上工作。我们正在创作个人的计划步骤，并试图找出如何在运行时将其转化为正确的行为——但我们真正想做的是，在高层次上创作人们的整个日常生活，这样我们就可以对事情发生的时间和变化方式有很强的作者控制力。我们需要创作的内容不是“我将如何应对这种情况”，而是“我的工作日今天、明天和后天是什么样子的”

用例程表示行为在人工智能中无疑有着丰富的历史。一些以人类学为导向的研究（例如，Schank 和 Abelson 1977，Suchman 1987）提出了一个令人信服的案例，即我们日常的人际交往确实是高度常规化的：在标准情况下，人们学习（或弄清楚）什么时候做什么，而不必从第一原则中重新驱动它，这些刻板的例程驱动着他们的行为。

一旦我们意识到我们在错误的抽象层次上建模行为，解决方案就很明显了：我们决定完全放弃计划，将 NPC 行为重新实现为刻板脚本库，这些脚本是对日常活动的描述，如去办公室、坐下来吃饭、处理租户的维修请求等。然后，脚本将被捆绑在各种日常计划中，根据当前条件，如一天中的时间和简单“工作记忆”的内容（例如，NPC 想去哪里、当前工作在哪里、当前家在哪里等的信息），用非常简单的逻辑选择正确的脚本。下面是一个日常脚本的示例定义，适用于在办公室长时间工作的人：

```
name "schedule-office.7"
blocks [
    { from 8 to 20 tasks [ go-work-at-workstation ] }
    { from 20 to 8 tasks [ go-stay-offsite ] }
]
oneshots [
    { at 8 prob 1 tasks [ go-get-coffee ] }
    { at 12 prob 1 tasks [ go-get-lunch ] }
    { at 15 prob 0.5 tasks [ go-get-coffee ] }
    { at 17.5 prob 0.25 tasks [ go-visit-retail ] }
    { at 20 prob 0.5 tasks [ go-get-dinner ] }
    { at 20 prob 0.25 tasks [ go-get-drink ] }
]
```

该定义分为两部分。在街区部分，我们看到他们从早上 8 点到晚上 8 点在指定的工作站（例如他们的办公桌）工作，否则就呆在家里。那些连续的脚本，如在工作站上工作，是作为简单的循环活动执行的，重复但有可调的变化。然后，oneshots 部分指定了可能发生或可能不发生的单个单镜头脚本，具体取决于概率修饰符 prob，每个脚本本身都有额外的逻辑来决定该做什么（例如，去喝咖啡可能会启动，导致 NPC 去买一杯咖啡，从而在你的大楼里花钱，但如果大楼里没有咖啡馆，它将中止并导致 NPC 抱怨）。最后，如下一节所述，所有这些脚本都按照单个操作的顺序自下而上。

与我们之前的计划方法相比，这种知识表示很简单，但这是一种积极的权衡。有趣的是，在预生产的早期，我们还尝试了一种更复杂的NPC内部人格模型，其中包括饥饿或疲劳等生理状态，但随着时间的推移，我们删除了所有这些细节。原因有两个：（1）内部状态充当了“隐藏信息”，使设计者和玩家都难以理解为什么一个人会以某种方式行事；（2）当乘以数十或数百个 NPC 时，这导致了许多令人沮丧的时刻，试图理解整个群体何时会出乎意料地行事。

我们的主要结论是，详细 NPC 代表的效用与玩家必须管理的 NPC 数量成反比。当模拟的人数很少时，玩家会欣赏他们的复杂性。然而，随着数字的增加，这并没有扩大。必须详细理解和管理它们对玩家和设计师来说都是一种负担，因此随着 NPC 数量的增加，最好提高抽象级别，并限制玩家必须处理的复杂性。

## 34.3 行动表现

我们的两个动作选择系统——计划器和脚本调度器——都产生了NPC需要执行的动作序列。在本节中，我们将看看硬币的另一面：动作表演。我们还将讨论实现高效实现的两个简化：开环动作性能和特定于域的寻路表示。

### 34.3.1 动作队列和开环动作性能

许多 NPC AI 系统都是闭环反馈系统——它们在执行操作时监控世界，并适当调整行为，主要是为了智能地处理故障。然而，这是有代价的：检查世界具有非零的计算成本（基于更新频率、感官模型的保真度等），决定是否对这些新信息采取行动也是如此。一些架构，如包容（Brooks 1986）或远程主动树（Nilsson 1994），接受不断的重新计算和重新计算作为做生意的成本，而各种行为树实现，例如，在各个节点是以远程主动方式重新验证自己还是长时间缓存其激活方面存在很大差异。

在我们的系统中，我们将这一点推向了一个极端：我们几乎完全开环地运行动作性能，而不试图根据世界的变化来监控和修复我们的行为。主要的 AI 设置看起来像这样：

1. 动作选择选择选择一个脚本（例如，去上班），并将其与NPC的工作记忆（例如，我在 243 号办公室工作）相结合，产生一系列简单的动作：进入大厅，等待电梯，乘坐电梯，走进 243 号办公室，坐在我的办公桌前等。
2. 动作被放入动作队列并按线性顺序执行。这在（Zubek 2010）中有详细介绍，但任何玩过《模拟人生》或经典基地建设实时战略游戏的人都会立即熟悉它在运行时的工作原理。
3. 每个操作都可以选择性地监视自定义故障条件。例如，如果找不到到达目的地的路径，导航操作将失败。
4. 如果检测到故障，队列将立即刷新，并且可以选择将回退脚本排队（例如，转向相机，播放不满意的动画，并抱怨这栋楼的条件）。
5. 一旦队列为空，系统会再次运行动作选择，它会选择下一组动作并重新填充队列。

实际上，系统只在无事可做时评估世界，一旦确定了行动方案，它就会开环运行，直到成功或中断。这些动作序列最终也相当短——例如，一个去餐馆吃饭的脚本可能会产生十几个单独的动作，总共需要大约一个小时的游戏时间（或：不到一分钟的实时时间）来执行。

这要归功于这个游戏世界的良性本质：通常可以在不太关注世界的情况下开环运行。如果确实发生了意外，行动选择非常便宜，我们可以放弃之前的活动重新开始。因此，简而言之，对于允许它的游戏设计来说，廉价的动作选择可以实现一系列其他简化，例如跳过适当的故障处理，转而重新开始。

### 34.3.2 简化模型的寻路

第二个优化与寻路有关。游戏发生在一个基本上是二维网格的地方——一个建筑物的剖面侧视图，根据场景的不同，它可以是 100 多层楼高，几百个网格单元宽。当数百名 NPC 试图同时在网格中导航时，在原始网格表示上天真地实现 A* 寻路很快就被证明是不够的。

当然，我们将寻路重新表述为分层的，以减少搜索空间。然而，我们没有使用通用的聚类方法，例如 HPA*（Botea 等人，2004），而是使用我们的领域知识来生成一个专门的紧凑表示，这使得玩家更容易对路径图进行持续的更改（当他们构建、更改或扩展其高层建筑时）。简而言之：根据游戏的设计，可路径空间被划分为不同的地板，这些地板是同一地板上连续的瓷砖序列，这样角色就可以在地板内做直线运动。此外，每个地板都通过楼梯、自动扶梯或电梯与上面或下面的地板相连，统称为连接器。楼板和连接件分别成为我们高级图中的节点和边，每个楼板内的运动变成了简单的直线方法。

这种搜索空间的减少是显著的：以一栋 100 层高、150 瓦宽、有四个电梯井的密集建筑为例，我们将空间从15000个网格单元减少到只有 100 个图形节点，它们之间有 400 条边。此时，数据模型足够小，可以继续运行A*，对启发式函数的额外调整可以防止开集不必要地散开。

我还应该补充一点，我们考虑了原始网格上的 JPS 和 JPS+ 等替代方案，但发现它们不太合适，因为玩家会一直改变网格空间。特别是，JPS（Harabor 和 Grastien 2012）根据需要有效地构建了一个紧凑的表示，以简化其搜索，但随着玩家不断更换游戏板，它将不得不一次又一次地重复它——这似乎不如一开始就保持源数据模型紧凑那么理想。此外，JPS+（Rabin 2015）通过预处理搜索空间获得了性能优势，但这是一个昂贵的步骤，不打算在游戏运行时重复应用。

最后，尽管我们考虑了比 A* 更复杂的方法，但一旦我们意识到如何优化搜索空间而不是优化算法，它们就变得没有必要了。我们利用我们的领域知识大幅简化了数据模型，以至于算法的选择不再重要，这是一个非常积极的发展。人工智能的许多领域都涉及搜索，模型简化是一种使其更易于处理的经典技术。

## 34.4 结论

角色 AI 的大幅简化使我们能够以 60 FPS 的速度实现 1000 个 NPC 的目标，同时降低开发成本。这是一个很好的例子，说明了超级专业化人工智能实现的强大功能，尽管它不能推广到更复杂的行为或更恶劣的环境中，但它非常适合手头的问题，并且没有超出最低要求的额外计算（或创作）负担。

这可能是一个有趣的例子，说明根据手头的问题定制人工智能实现的好处，而不是依赖更通用的中间件。尽管通用解决方案有其地位，但通过无情地削减复杂性，直到没有什么可削减的，可以取得惊人的成就。